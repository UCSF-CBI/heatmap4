---
title: "heatmap4"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{heatmap4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Introduction
This package takes the original heatmap function and reduces the argument complexity. 

A heatmap is a false color image (image(t(x))) with a dendrogram added to the top and left side. Typically, reordering of the rows and columns according to some set of values (row or column means) within the restrictions imposed by the dendrogram is carried out.


```{r, echo=FALSE}
if (F) {
  ## Calling Bioconductor
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

  BiocManager::install("marray")
  load("data_gen.rda")
}
```
## 2. Loading Libraries

```{r, include=FALSE}
library(RColorBrewer)
library(marray)
library(dplyr)
```

```{r}
library(heatmap4)
```

```{r, include = FALSE}
library(dplyr)
```

```{r, include = FALSE}
#heatmap4source
heatmap4 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,
hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),
scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,
cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",
totalR=nr, totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),
methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",
addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidHeatmap=4, lheiHeatmap=4, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, sideLabRow=4, sideLabCol=1, layoutRespect=T, sideColSide=c("left","right"), sideRowSide=c("bottom","top"), ...)
### 26. Ritu

{
    
    print("heatmap4: zlm")
    print(zlm)
    
    ## 4. Ritu
    if (!is.matrix(x)) {f
        x <- matrix(x,ncol=1)
        if (!is.null(addamps)) {
            addamps <- matrix(addamps,ncol=1)
        }
        ## 19. Ritu
        if (!is.null(addText)) {
            addText <- matrix(addText,ncol=1)
        }
    }
    scale <- if (symm && missing(scale)) "none" else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) stop("`x' must be a numeric matrix")
    nr <- di[1]
    nc <- di[2]
    ## 27. Ritu
    sideRowSide=sideRowSide[1]
    sideColSide=sideColSide[1]
    ## 4. Ritu
    #if (nr <= 1 || nc <= 1) stop("`x' must have at least 2 rows and 2 columns")
    if (nr <= 1 || nc < 1) stop("`x' must have at least 2 rows and 1 column")
    if (!is.numeric(margins) || length(margins) != 2) stop("`margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (is.null(Rowv)) Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "hclust")) {
            ## 16. Ritu
            hcr <- Rowv
            ddr <- as.dendrogram(hcr)
        } else if (inherits(Rowv, "dendrogram"))
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x), method = methodR)
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) {
                ddr <- reorder(ddr, Rowv)
                ## 30. Ritu
                hcr <- as.hclust(ddr)
            }
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) stop("row dendrogram ordering gave index of wrong length")
    } else rowInd <- 1:nr
    if (doCdend) {
        if (inherits(Colv, "hclust")) {
            ## 16. Ritu
            hcc <- Colv
            ddc <- as.dendrogram(hcc)
        } else if (inherits(Colv, "dendrogram"))
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) x else t(x)), method = methodC)
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) {
                ddc <- reorder(ddc, Colv)
                ## 30. Ritu
                hcc <- as.hclust(ddc)
            }
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) stop("column dendrogram ordering gave index of wrong\nlength")
    } else colInd <- 1:nc
    ## 28. Ritu
    if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr) else rownames(x)
    if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc) else colnames(x)
    x <- x[rowInd, colInd]
    ## 28. Ritu
    #if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr)[rowInd] else rownames(x)
    #if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc)[colInd] else colnames(x)
    if (scale == "row") {
        x <- sweep(x, 1, rowMeans(x, na.rm = na.rm))
        sx <- apply(x, 1, sd, na.rm = na.rm)
        x <- sweep(x, 1, sx, "/")
    } else if (scale == "column") {
        x <- sweep(x, 2, colMeans(x, na.rm = na.rm))
        sx <- apply(x, 2, sd, na.rm = na.rm)
        x <- sweep(x, 2, sx, "/")
    }
    lmat <- rbind(c(NA, 3), 2:1)
    #lwid <- c(if (doRdend) 1 else 0.05, 4)
    #lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 4)

    ## 27. Ritu
    ### 7. Ritu
    ##lwid <- c(1, 4)
    ##lhei <- c(1 + if (!is.null(main)) 0.2 else 0, 4)
    #lwid <- c(ifelse(doRdend,1,0.01), 4)
    #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), 4)
    lwid <- c(ifelse(doRdend,1,0.01), lwidHeatmap)
    lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), lheiHeatmap)

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
           # if (!is.character(ColSideColors) || length(ColSideColors) !=
            #    nc)
              #  stop("'ColSideColors' must be a character vector of\nlength ncol(x)")

            ## 6. Ritu
            if (!is.matrix(ColSideColors)) {
                ColSideColors <- matrix(ColSideColors,nrow=1)
                rownames(ColSideColors) <- ""
            }

        ## 11. Ritu
        #lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lmat <- rbind(lmat[1, ] + 1, c(rep(NA, ncol(lmat) - 1),1), lmat[2, ] + 1)

        ## 24. Ritu
        lhei <- c(lhei[1], 0.2, lhei[2])
    }
    ## 3. Ritu
    if (!is.null(RowSideColors)) {
        #if (!missing(RowSideColors)) {
            #if (!is.character(RowSideColors) || length(RowSideColors) != nr)
            #    stop("'RowSideColors' must be a character vector of\nlength nrow(x)")
            #lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
            #lwid <- c(lwid[1], 0.2, lwid[2])

        ## 11. Ritu
        if (!is.matrix(RowSideColors)) {
            RowSideColors <- matrix(RowSideColors,nrow=1)
            rownames(RowSideColors) <- ""
        }
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
        ## 24. Ritu
        #lwid <- c(lwid[1], 0.2, lwid[2])
        lwid <- c(lwid[1], lwidRowSide, lwid[2])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

################################
#redo lmat:

    ## 1. Ritu
    #if (!is.matrix(ColSideColors)) {
        #ColSideColors <- matrix(ColSideColors,nrow=1,dimnames=list(names(ColSideColors),1:nc))
    #}

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        nr.my=nrow(ColSideColors)+2

        ## 11. Ritu
        #nc.my=3
        #nfig=nr.my+2
        #lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        #lmat[nr.my,]=c(nfig-1,1,nfig-2)
        #lmat[1, nc.my]=nfig
        #lmat[2:(nr.my-1),nc.my]=(nfig-3):2
        nc.my=2+ifelse(is.null(RowSideColors),0,nrow(RowSideColors))
        nfig=nr.my+nc.my-1
        lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        if (is.null(RowSideColors)) {
            lmat[nr.my,]=c(nfig-1,nfig-2)
        } else {
            lmat[nr.my,]=c(nfig-1,1:nrow(RowSideColors),nfig-2)
            ## 27. Ritu
            ## 24. Ritu
            ##lwid <- c(ifelse(doRdend,1,0.01), rep(.2, nrow(RowSideColors)), 4)
            #lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), 4)
            lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), lwidHeatmap)
        }
        lmat[1, nc.my]=nfig
        lmat[2:(nr.my-1),nc.my]=(nfig-3):(nc.my-1)

        ## 11. Ritu
        ### 10. Ritu
        #if (is.null(RowSideColors)) {
        #    lmat=lmat[,c(1,3:ncol(lmat))]
        #    lmat=lmat-1
        #    lmat[lmat==(-1)]=0
        #}

        ## 27. Ritu
        ### 24. Ritu
        #### 7. Ritu
        ###lhei=c(1, rep(.2, nrow(ColSideColors)),4)
        ##lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(ColSideColors)), 4)
        #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(lheiColSide, nrow(ColSideColors)), 4)
        lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,lheiColSide), rep(lheiColSide, nrow(ColSideColors)), lheiHeatmap)
    }
    
    notRequired=function(x) {
        ## 11. Ritu
        if (!is.null(RowSideColors)) {
            nr.my=nrow(RowSideColors)+2
            nc.my=nrow(ColSideColors)+2
            nfig=nr.my+2
            lmat=matrix(0, nrow=nr.my, ncol=nc.my)
            lmat[nr.my,]=c(nfig-1,1,nfig-2)
            lmat[1, nc.my]=nfig
            lmat[2:(nr.my-1),nc.my]=(nfig-3):2
            if (is.null(ColSideColors)) {
                lmat=lmat[,c(1,3:ncol(lmat))]
                lmat=lmat-1
                lmat[lmat==(-1)]=0
            }
            lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(RowSideColors)), 4)
        }
    }

###################################
    op <- par(no.readonly = TRUE)
    on.exit(par(op))
    if (verbose) {
        cat("Final layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

    ## 26. Ritu
    ##layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    #layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = layoutRespect)
    #layout.show(layoutThis)
    #layout.show(n=nfig)

    ## 3. Ritu
    if (!is.null(RowSideColors)) {
    #if (!missing(RowSideColors)) {
        par(mar = c(margins[1], 0, 0, 0.5))

        ## 11. Ritu
        #if (revC) {
        #    image(rbind(1:nr), col = RowSideColors[rev(rowInd)], axes = FALSE)
        #} else {
        #    image(rbind(1:nr), col = RowSideColors[rowInd], axes = FALSE)
        #}
        if (revC) {
            j=rev(rowInd)
        } else {
            j=rowInd
        }
        for (i in 1:nrow(RowSideColors)) {
            ## 27. Ritu
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            ##image(rbind(1:nr), z=rbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            ##image(cbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(RowSideColors[i,j]))) {
                    for (jj in which(is.na(RowSideColors[i,j]))) {
                        rect(-1,jj-0.5,1,jj+0.5,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ### 24. Ritu
            ##mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=1)
            #mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
            mtext(side=ifelse(sideRowSide=="bottom",1,3), text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
        }
    }
    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2]))
        for (i in 1:nrow(ColSideColors)) {
            ## 9. Ritu
            #image(cbind(1:nc), col = ColSideColors[i,colInd], axes = FALSE)
            image(cbind(1:nc), z=cbind(1:nc),col = ColSideColors[i,colInd], axes = FALSE, xlim = 0.5 + c(0, totalC))
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(ColSideColors[i,colInd]))) {
                    for (jj in which(is.na(ColSideColors[i,colInd]))) {
                        rect(jj-0.5,-1,jj+0.5,1,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ## 24. Ritu
            #mtext(side=2, text=as.character(rownames(ColSideColors)[i]), las=1, cex=1)
            mtext(side=ifelse(sideColSide=="left",2,4), text=as.character(rownames(ColSideColors)[i]), las=1, cex=cexColSide)
        }
    }
    par(mar = c(margins[1], 0, 0, margins[2]))
    if (!symm || scale != "none")
        x <- t(x)
    if (revC) {
        iy <- nr:1
        ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1:nr
    x.floor <- x
    for (i in 1:ncol(x)) {
        ind1 <- (1:length(x[, i]))[x[, i] >= zlm[2] & !is.na(x[,i])]
        ind2 <- (1:length(x[, i]))[x[, i] <= zlm[1] & !is.na(x[,i])]
        x.floor[, i][ind1] <- rep((zlm[2] - 0.01), length(ind1))
        x.floor[, i][ind2] <- rep((zlm[1] + 0.01), length(ind2))
    }
    ## 5. Ritu
    #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, nc), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
    if (length(high)>1) {
        ## 20. Ritu
        colThis=high
    } else {
        colThis=maPalette(high = high, low = low, mid = mid)
    }
    if (nc==1) {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    } else {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    }
    ## 15. Ritu
    if (!is.null(lineCol)) {
        ## 22. Ritu
        #abline(v=lineCol)
        abline(v=lineCol,col=lineColor)
    }
    ## 15. Ritu
    if (!is.null(lineRow)) {
        ## 27. Ritu
        ### 22. Ritu
        ##abline(h=lineRow)
        #abline(h=lineRow,col=lineColor)
        for (i in lineRow) lines(x=c(1-0.5,nc+0.5),y=rep(i,2), col=lineColor)
    }

##################

## 19. Ritu
if (!is.null(addText)) {
    addText=addText[rowInd, colInd]
    if (!is.matrix(addText)) {
        addText <- matrix(addText,ncol=1)
    }
    for (i in 1:ncol(addText)) {
        j=which(!is.na(addText[,i]))
        ## 23. Ritu
        #points(rep(i, length(j)), j, pch=addText[j,i])
        if (length(j)!=0) text(i, j, labels=addText[j,i], cex=cexText)
    }
}

if (!is.null(addamps)) {
    addamps=addamps[rowInd, colInd]
    ## 4. Ritu
    if (!is.matrix(addamps)) {
        addamps <- matrix(addamps,ncol=1)
    }
    for (i in 1:ncol(addamps)) {
        amp=which(addamps[,i]>0)
        ## 12. Ritu
        ### 8. Ritu
        ##points(rep(i, length(amp)), amp, col=colamps, cex=.75, pch=20)
        #points(rep(i, length(amp)), amp, col=colamps, cex=.25, pch=20)
        points(rep(i, length(amp)), amp, col=colamps, cex=cexAmp, pch=20)
    }
 }
    
################

    ## 25. Ritu
    ### 17. Ritu
    ##axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
    #axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    axis(sideLabCol, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    if (!is.null(xlab))
        mtext(xlab, side = 1, line = margins[1] - 1.25)
    ## 25. Ritu
    ### 17. Ritu
    ##axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
    #axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    axis(sideLabRow, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    if (!is.null(ylab))
        mtext(ylab, side = 4, line = margins[2] - 1.25)
    if (!missing(add.expr))
        eval(substitute(add.expr))
    ## 27. Ritu
    #par(mar = c(margins[1], 0, 0, 0))
    xr=ifelse(totalR==nr,margins[1],2*(totalR-nr)+1+margins[1])
    xc=0
    par(mar = c(xr, 0, 0, xc))
    if (doRdend) {
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcr") & !is.na(ncr)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcr,k=ncr) else stop("Must be of class hclust to delineate clusters")
            if (class(hcr)=="hclust") rect.hclust.my(hcr,k=ncr,horiz=TRUE) else stop("Must be of class hclust to delineate clusters")
        }
    } else {
        frame()
    }
    ## 27. Ritu
    ## 9. Ritu
    #if (totalC==nc) {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2]))
    #} else {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, 2*(totalC-nc)+1+margins[2]))
    #}
    xr=0
    xc=ifelse(totalC==nc,margins[2],2*(totalC-nc)+1+margins[2])
    par(mar = c(xr, 0, if (!is.null(main)) 1 else 0, xc))
    if (doCdend) {
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcc") & !is.na(ncc)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
            if (class(hcc)=="hclust") rect.hclust.my(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
        }
    } else if (!is.null(main)) {
        frame()
    }
    if (!is.null(main)) {
        ## 27. Ritu
        if (doCdend) {
            title(main, cex.main=0.8 * op[["cex.main"]])
            #text(x=20,y=5,main,cex=1 * op[["cex.main"]],font=2)
        } else {
            text(x=0.5,y=0.5,main,cex=1.5 * op[["cex.main"]],font=2)
        }
        #title(main, cex.main = 1.5 * op[["cex.main"]])
        #title(main, cex.main = 1.5 * op[["cex.main"]],line = margins[1] - 1.25)
        #plot(1,type="n",xaxt="n",yaxt="n",xlab="",ylab="");
        #text(x=10+margins[1] - 1.25,y=1,"test",cex=1.5 * op[["cex.main"]],)
        #text(x=1,y=1,c("test","ok"),cex=1.5 * op[["cex.main"]])
        #text(x=0.5,y=1,c("tex"),cex=1.5 * op[["cex.main"]])
        #points(rep(0,10),1:10)
    }

    ## 13. Ritu
    #invisible(list(rowInd = rowInd, colInd = colInd))
    out=list(rowInd = rowInd, colInd = colInd, rowClust=NULL, colClust=NULL)

    ## 14. Ritu
    #if (doRdend) out$rowClust=hcr
    #if (doCdend) out$colClust=hcc
    if (exists("hcr")) out$rowClust=hcr
    if (exists("hcc")) out$colClust=hcc
    
    ## 29. Ritu
    if (exists("hcr") & !is.na(ncr)) {
        y=cutree(hcr,ncr)
        y=y[out$rowInd]
        out$rowClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncr) {
            out$rowClustId[which(y==y[k1[k]])]=k
        }
    }
    if (exists("hcc") & !is.na(ncc)) {
        y=cutree(hcc,ncc)
        y=y[out$colInd]
        out$colClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncc) {
            out$colClustId[which(y==y[k1[k]])]=k
        }
    }

    invisible(out)
}

rect.hclust.my=function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL, horiz = FALSE) {
    if (length(h) > 1L | length(k) > 1L) stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k))
        stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    } else if (is.null(k)) {
        stop("specify exactly one of 'k' and 'h'")
    }
    if (k < 2 | k > length(tree$height))
    stop(gettextf("k must be between 2 and %d", length(tree$height)), domain = NA)
    if (is.null(cluster))
    cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which))
        stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which))
    which <- 1L:k
    if (any(which > k))
    stop(gettextf("all elements of 'which' must be between 1 and %d", k), domain = NA)
    border <- rep_len(border, length(which))
    retval <- list()
    for (n in seq_along(which)) {
        if (horiz) {
            ## 18. Ritu
            rect(mean(rev(tree$height)[(k - 1):k]), m[which[n]] + 0.66, par("usr")[2L], m[which[n] + 1] + 0.33, border = border[n])
        } else {
            rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
        }
#        rect(xleft, ybottom, xright, ytop, density = NULL, angle = 45,col = NA, border = NULL, lty = par("lty"), lwd = par("lwd"),
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}

######################################################################


script <- function() {
library(RColorBrewer)
library(marray)
library(sma)
library(aCGH)

#row colors (chromosomes)

chrominfo=human.chrom.info.Jul03
clinfo <- clones.info(tumor.acgh)
chromcols <- rep(NA, nrow(clinfo))

for (i in 1:23)
{
    if (is.odd(i))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "yellowgreen"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "green"
        chromcols[which(clinfo$Chrom==i)] <- "gray10"
        
    }
    else if (!(is.odd(i)))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "skyblue"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "blue"
        chromcols[which(clinfo$Chrom==i)] <- "gray90"
        
    }
}

sampnm1 <- sample.names(tumor.acgh)[ind.match.tumor]

ind.samp <- which(!is.na(ind.match.tumor))
ind.cl=which(clinfo$Chrom<=23 & clinfo$Clone!="RMC01P009")

#create color bars accoridng to clinical variables

sampCols=matrix(NA, nrow=7, ncol=nrow(phenData))

#expression subtype

rsp=as.numeric(phenData$subCor)
tmp=brewer.pal(length(unique(rsp[!is.na(rsp)])),"Accent")

sampcols <- rep(NA, length(rsp))
for (i in 1:length(tmp))
{
    sampcols[which(rsp==i)]=tmp[i]
}
sampcols[which(sampcols=="#FFFF99")]="yellow2"
sampCols[1,]=sampcols

#pr
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$pr=="pos")]=1
rsp[which(phenData$pr=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[2,]=sampcols

#er
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$er=="pos")]=1
rsp[which(phenData$er=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[3,]=sampcols

#p53
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$p53==0)]=1
rsp[which(phenData$p53==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[4,]=sampcols

#ki67

rsp=I(phenData$ki67>10)
rsp[which(rsp==TRUE)]=2
rsp[which(rsp==FALSE)]=1

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[5,]=sampcols

#size

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$size<=median(phenData$size, na.rm=T))]=1
rsp[which(phenData$size>median(phenData$size, na.rm=T))]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[6,]=sampcols

#nodal.status

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$nodal.status==0)]=1
rsp[which(phenData$nodal.status==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[7,]=sampcols

########################

rownames(sampCols)=c("Expression subtype", "PR status", "ER status", "p53 status", "ki67 status", "size", "nodal status")

#########################

#main data (smoothed with outliers)
tmp <- tumor.smoothed.impute.aber$aber.val[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

#amplifications to be added as yellow dots
tmpamp <- tumor.amplif[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

postscript("try.ps", paper="letter")
try10=heatmap3(x=tmp[,ind.samp], Rowv=NA, Colv=NULL, distfun = dist.cor.func, hclustfun = hclust,  symm=F, ColSideColors = sampCols[,ind.samp], RowSideColors=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))], labCol=as.character(sampnm1)[ind.samp], labRow=NA, scale="none", na.rm = F, margins = c(5, 5), main = NULL, xlab = NULL, ylab = NULL, zlm=c(-.5,.5), addamps=tmpamp[,ind.samp], colamps="yellow")
dev.off()
}
```

```{r, include = FALSE}
#HeatmapRelated.R
plotHeatmap <- function(dataAcgh, clInfo, distMethod="euclidean",clustCol=T,clustRow=F,numChrom=nAut,resp=NULL,samId=1:ncol(dataAcgh),samName=NULL,amplif=NULL,phenName="",phenColor=NULL, main=NULL, candidateClone=F,cloneInfo=NULL,margins=c(5,5),chrInfo.this=chrInfo,chromCol=c("skyblue","blue","yellowgreen","yellow"),cexCol=NULL) {
	if (!is.null(resp)) {
		if (!is.matrix(resp)) {
			resp <- matrix(resp,nrow=1)
		}
		nPhen <- nrow(resp)
	}

	## ------------------------------------------
	## Chroms
	ind.cl <- which(clInfo$Target%in%clones.info(acghNA)$Target)
	chromcols <- rep(NA, nrow(clInfo))
	for (i in 1:numChrom) {
		if (is.odd(i)) {
			chromcols[which(clInfo$Chrom==i & clInfo$kb < chrInfo.this$centr[i])] <- chromCol[1]
			chromcols[which(clInfo$Chrom==i & clInfo$kb >= chrInfo.this$centr[i])] <- chromCol[2]
		} else if (!(is.odd(i))) {
			chromcols[which(clInfo$Chrom==i & clInfo$kb < chrInfo.this$centr[i])] <- chromCol[3]
			chromcols[which(clInfo$Chrom==i & clInfo$kb >= chrInfo.this$centr[i])] <- chromCol[4]
		}
	}

	## ------------------------------------------

	dat=dataAcgh[ind.cl,samId]
	#colnames(dat) <- colnames(dataAcgh)[samId]

	## ------------------------------------------
	## Samples
	if (is.null(samName)) {samName <- colnames(dataAcgh)[samId]}

	if (is.null(resp)) {
		sampCols <- NULL
	} else {
		sampCols=matrix(NA, nrow=nPhen, ncol=length(samId))
		for (i in 1:nrow(resp)) {
			respUniq <- 0:(length(unique(resp[i,][!is.na(resp[i,])]))-1)
			if (is.null(phenColor) || is.null(phenColor[[i]])) {
				tmp=brewer.pal(min(length(respUniq),3),"Accent")
				if (length(tmp)<length(respUniq)) {
					tmp=c(brewer.pal(length(respUniq),"Set3"),brewer.pal(length(respUniq),"Set2"))[1:length(respUniq)]
					tmp=c(brewer.pal(length(respUniq),"Set3"),brewer.pal(length(respUniq),"Set2"))[1:length(respUniq)]
					tmp[1] <- "#1F78B4"
					if (length(tmp)>8) {
						tmp[9] <- "#999999"
					}
				}
				tmp<- tmp[1:length(respUniq)]
				tmp[tmp=="#FFFF99"]="#FFFF60"
			} else {
				tmp <- phenColor[[i]]
			}
			sampcols <- rep(NA, length(resp[i,]))
			for (j in 1:length(respUniq)) {
				sampcols[which(resp[i,]==respUniq[j])] <- tmp[j]
			}
			sampcols[which(sampcols=="#FFFF99")]="yellow2"
			sampCols[i,]=sampcols
		}
		sampCols <- matrix(sampCols,nrow=nPhen)
		rownames(sampCols) <- phenName
	}
	## ------------------------------------------

	cat("Check for flooring:\n")
	print(round(summary(as.vector(dat)),2))
	if (!is.null(distMethod)) {
		if (distMethod=="euclidean") {distfun <- dist
		} else {distfun <- getDist}
	}

	dat <- dataAcgh[ind.cl,samId][rev(1:nrow(clInfo[ind.cl,])),]
	if (candidateClone) {
		id <- as.character(clInfo$Clone)[ind.cl][rev(1:nrow(clInfo[ind.cl,]))]%in%as.character(clInfo$Clone)
		dat <- dat[id,]
		cloneName <- paste(clInfo$Clone," chr",clInfo$Chr," kb",clInfo$kb,sep="")[ind.cl][rev(1:nrow(clInfo[ind.cl,]))][id]
		tmp <- as.character(clInfo$Clone)[ind.cl][rev(1:nrow(clInfo[ind.cl,]))][id]
		id <- match(tmp,as.character(cloneInfo[,1]))
		cloneCol <- rep("white",length(cloneName))
		cloneCol[!is.na(id)] <- as.character(cloneInfo[,2])[id[!is.na(id)]]
	}
	if (is.null(distMethod)) {
		clustSamples=NULL
		clustClones=NULL
	} else {
		if (clustCol) {
			clustSamples=hclust(getDist(t(dat),method=distMethod),method="ward")
		} else {
			clustSamples=NULL
		}
		if (clustRow) {
			if (candidateClone) {
				clustClones=NULL
			} else {
				if (!is.null(cloneInfo)) {
					id <- as.character(clInfo$Clone)[ind.cl][rev(1:nrow(clInfo[ind.cl,]))]%in%as.character(clInfo$Clone)
					dat <- dat[id,]
					cloneName <- paste(clInfo$Clone," chr",clInfo$Chr," kb",clInfo$kb,sep="")[ind.cl][rev(1:nrow(clInfo[ind.cl,]))][id]
					tmp <- as.character(clInfo$Clone)[ind.cl][rev(1:nrow(clInfo[ind.cl,]))][id]
					id <- match(tmp,as.character(cloneInfo[,1]))
					cloneCol <- rep("white",length(cloneName))
					cloneCol[!is.na(id)] <- as.character(cloneInfo[,2])[id[!is.na(id)]]
				}
				clustClones=hclust(getDist(dat,method=distMethod),method="ward")
			}
		} else {
			clustClones=NULL
		}
	}
	if (is.null(clustSamples)) {
		clustSamples2=NA
	} else {
		clustSamples2=as.dendrogram(clustSamples)
	}
	if (is.null(clustClones)) {
		clustClones2=NA
		cloneCol=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))]
		cloneName=NA
	} else {
		clustClones2=as.dendrogram(clustClones)
	}

	if (is.null(amplif)) {
		datAmp=NULL; colAmp=NULL
	} else {
		datAmp <- amplif[ind.cl,samId][rev(1:nrow(clInfo[ind.cl,])),]
		colAmp="yellow"
		if (candidateClone) {
			datAmp <- datAmp[(as.character(clInfo$Clone)[ind.cl][rev(1:nrow(clInfo[ind.cl,]))]%in%as.character(clInfo$Clone)),]
		}
	}
	if (!is.null(distMethod)) {
		if (candidateClone) {
			hcc <- heatmap3(x=dat, Rowv=NA, Colv=clustSamples2, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=cloneCol, labCol=samName, labRow=cloneName, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp)
		} else {
			if (is.null(cexCol)) {
				hcc <- heatmap3(x=dat, Rowv=clustClones2, Colv=clustSamples2, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=cloneCol, labCol=samName, labRow=cloneName, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp)
			} else {
				hcc <- heatmap3(x=dat, Rowv=clustClones2, Colv=clustSamples2, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=cloneCol, labCol=samName, labRow=cloneName, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp, cexCol=cexCol, totalC=ncol(dataAcgh))
			}
		}
	} else {
		if (candidateClone) {
			hcc <- heatmap3(x=dat, Rowv=NA, Colv=NA, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=cloneCol, labCol=samName, labRow=cloneName, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp)
		} else {
			if (is.null(cexCol)) {
				hcc <- heatmap3(x=dat, Rowv=NA, Colv=NA, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))], labCol=samName, labRow=NA, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp)
			} else {
				hcc <- heatmap3(x=dat, Rowv=NA, Colv=NA, distfun=distfun, hclustfun=hclust, symm=F, ColSideColors=sampCols, RowSideColors=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))], labCol=samName, labRow=NA, scale="none", na.rm=F, margins=margins, main=main, xlab=NULL, ylab=NULL, zlm=limit, addamps=datAmp, colamps=colAmp, cexCol=cexCol, totalC=ncol(dataAcgh))
			}
		}
	}

	invisible(list(clustSamples,clustClones))
}

heatmapColorBar <- function(limit,cols=c("green","red","black"),main=NULL,...) {
    if (length(cols)==3) {
        try <- maPalette(high=cols[1], low=cols[2], mid=cols[3])
    } else {
        ## 5. Ritu
        try <- maPalette(high=cols[1], low=cols[2])
    }
    maColorBar(try, scale=limit,main=main,...)
}

## 9. Ritu
### 6. Ritu
#### 1. Ritu
##sampleColorLegend <- function(tls,col=NULL,lty=NULL,legendTitle=NULL,cex=NULL) {
#sampleColorLegend <- function(tls,col=NULL,lty=NULL,legendTitle=NULL,cex=NULL,density=NULL) {
sampleColorLegend <- function(tls,col=NULL,lty=NULL,pch=NULL,lwd=NULL,legendTitle=NULL,cex=NULL,density=NULL) {
	nTypes <- length(tls)
	if (is.null(col)) {
		cl <- brewer.pal(8, "Accent")
		cl <- cl[1:min(nTypes,length(cl))]
		if (length(cl)<nTypes) {
			cl=c(brewer.pal(nTypes,"Set3"),brewer.pal(nTypes,"Set2"))[1:nTypes]
			cl[1] <- "#1F78B4"
			if (length(cl)>8) {
				cl[9] <- "#999999"
			}
		}
		cl <- cl[1:nTypes]
		cl[cl=="#FFFF99"]="#FFFF60"
	} else {
		cl <- col
	}
	fill=col=NULL
	if (is.null(lty)) {
		fill=cl
	} else {
		col=cl
	}
	n <- length(tls)
	ii <- 1:length(tls)
	if (is.null(cex)) {
		cex=ifelse(max(nchar(tls))>13,1.5,3)
		if (nTypes>6) {cex=1.5}
	}
	plot(0:length(tls),0:length(tls),type="n",axes=F,xlab="",ylab="")
	if (is.null(lty)) {
        if (is.null(density)) {
            ## 7. Ritu
            #legend(0,length(tls),tls,fill=fill,col=col,lty=lty,cex=cex,title=legendTitle)
            legend(0,length(tls),tls,fill=fill,col=col,lty=lty,border=fill,cex=cex,title=legendTitle)
        } else {
            ## 7. Ritu
            ### 6. Ritu
            #legend(0,length(tls),tls,col=fill,lty=lty,cex=cex,density=density,title=legendTitle)
            legend(0,length(tls),tls,col=fill,lty=lty,border=fill,cex=cex,density=density,title=legendTitle)
            if (F) {
                text(1,k-1,legendTitle)
                for (k in 1:length(tls)) {
                    rect(0,k-0.5,1,k+0.5,col=fill[k],density=density)
                    text(2,k,tls[k])
                }
            }
        }
	} else {
		legend(0,length(tls),tls,col=col,lty=lty,pch=pch,lwd=lwd,cex=cex,title=legendTitle)
	}
}

## 2. Ritu
#getDist <- function(dat,method="pearson") {
getDist <- function(dat,method="pearson",absolute=FALSE) {
	if (method=="pearson") {
		print(method)
		## 2. Ritu
		#as.dist(1 - cor(t(dat),use="complete.obs"))
		y=cor(t(dat),use="complete.obs")
		if (absolute) y=abs(y)
		as.dist(1-y)
	} else {
		dist(dat, method=method)
	}
}

#library(psy)
## 2. Ritu
getKappaDist=function(x,type="Cohen",absolute=FALSE) {
	res=matrix(nrow=ncol(x),ncol=ncol(x),dimnames=list(colnames(x),colnames(x)))
	for (k1 in 1:ncol(x)) {
		for (k2 in 1:ncol(x)) {
			res[k1,k2]=res[k2,k1]=lkappa(x[,c(k1,k2)], type=type)
		}
	}
	if (absolute) res=abs(res)
	as.dist(1-res)
}

## 3. Ritu
## Used for dichotomous data. Set the categories as -1 & 1
getCosineDist=function(x) {
    cos.sim <- function(ix) {
        A = x[ix[1],]
        B = x[ix[2],]
        return( sum(A*B)/sqrt(sum(A^2)*sum(B^2)) )
    }
    res=matrix(nrow=ncol(x),ncol=ncol(x),dimnames=list(colnames(x),colnames(x)))
    n <- nrow(x)
    cmb <- expand.grid(i=1:n, j=1:n)
    ## 4. Ritu
    #res <- matrix(apply(cmb,1,cos.sim),n,n)
    res <- matrix(apply(cmb,1,cos.sim),n,n,dimnames=list(rownames(x),rownames(x)))
    as.dist(1-res)
}

getCluster=function(dat,distMethod,linkMethod,absFlag=F) {
    switch(distMethod,
        "cosine"={
            if (any(apply(dat,2,sum,na.rm=T)==0)) dat=dat+1
            distMat=getCosineDist(t(dat))
            clustThis=hclust(distMat,method=linkMethod)},
        "pearson"={
            x=cor(dat,method=distMethod,use="complete.obs")
            if (absFlag) x=abs(x)
            distMat=as.dist(1-x)
            clustThis=hclust(distMat,method=linkMethod)},
        "spearman"={
            x=cor(dat,method=distMethod,use="complete.obs")
            if (absFlag) x=abs(x)
            distMat=as.dist(1-x)
            clustThis=hclust(distMat,method=linkMethod)},
        "kappa"={
            distMat=getKappaDist(dat,absolute=absFlag)
            clustThis=hclust(distMat,method=linkMethod)},
        "euclidean"={
            distMat=dist(t(dat),method=distMethod)
            clustThis=hclust(distMat,method=linkMethod)}
    )
    invisible(clustThis)
}

cutCluster=function(clustObj,ann,nClust=2,rev=F) {
    if (is.na(nClust)) {
        if (class(clustObj)=="hclust") {
            tbl=cbind(ann[clustObj$order,],order=1:nrow(ann))
        } else {
            tbl=cbind(ann,order=1:nrow(ann))
        }
    } else {
        tbl=matrix(nrow=nrow(ann),ncol=nClust-1)
        colnames(tbl)=paste("clustId_",1:ncol(tbl)+1,sep="")
        #for (kk in kVec) {
        for (kk in 1:ncol(tbl)) {
            clustId=cutree(clustObj,k=kk+1)[clustObj$order]
            k1=which(!duplicated(clustId))
            for (k in 1:length(k1)) {
                ## 8. Ritu
                #clustId[which(clustId==clustId[k1[k]])]=paste("cluster",k,sep="")
                if (rev) kThis=length(k1)-k+1 else kThis=k
                clustId[which(clustId==clustId[k1[k]])]=paste("cluster",kThis,sep="")
            }
            tbl[,kk]=clustId
        }
        tbl=cbind(ann[clustObj$order,],tbl,order=1:nrow(ann))
    }
    if (rev) {
        tbl=tbl[rev(1:nrow(tbl)),]
        tbl$order=1:nrow(tbl)
    }
    invisible(tbl)
}
```

```{r, include=FALSE}
## 7. Ritu 04/13/22 - Fix continuous row color bar
## 8. Ritu 05/13/22 - row_var not col_var for row color bar
## 9. Ritu 06/09/22 - Set no. of axis labels to 5 (k=5) in heatmapColorBar

## Wrapped heatmap function
generate_heatmap <- function(x, col_lab = c(FALSE,TRUE), row_lab = c(FALSE,TRUE), col_lab_vtr = NULL,
                             row_lab_vtr = NULL, col_anno = c(FALSE, TRUE), row_anno = c(FALSE,TRUE), col_info = NULL,
                             row_info = NULL, col_anno_var = NULL, row_anno_var = NULL, col_var_info = NULL,
                             row_var_info = NULL, col_dend = c(FALSE,TRUE), row_dend = c(FALSE,TRUE),
                             col_anno_name=NULL, row_anno_name=NULL,
                             # review col/row_clust and _dend
                             col_clust = NULL, row_clust = NULL,
                             plot_info = list(margins=c(0.5,0.5),cexCol=NULL,cexRow=NULL,cexColSide=NULL,cexRowSide=NULL,colorCatCol=NULL,colorCatRow=NULL,colorContCol=NULL,colorContRow=NULL),
                             file_name = NULL, h_title = NULL,input_legend = c(FALSE, TRUE), legend_title = NULL, heatmap_color=c("red", "blue", "grey"), zlm=c(-0.5, 0.5), ...)
{

  #--------------------------------------------------------------------------------------------
  ## Annotations
  input_legend <- input_legend[1]
  row_anno <- row_anno[1]
  col_anno <- col_anno[1]

  if (row_anno) {

    # Checks to see if row_info is a valid input
    if (class(row_info) != 'data.frame') {
      stop("row_info is meant to be a data.frame")
    }

    # Defining row annotation variable selection
    row_var <- c()

    # Looping through row annotation data frame
    if (is.null(row_anno_var)) {
      for (r in 1:ncol(row_info)) {
        if (is.numeric(row_info[ ,r]) | sum(!duplicated(row_info[ ,r])) < nrow(row_info)) {
          row_var <- c(row_var, colnames(row_info)[r])
        }
      }
    } else {
      k <- match(colnames(row_info), row_anno_var)
      k <- k[!is.na(k)]
      if (length(k) == 0) {
        row_var <- colnames(row_info)
        cat("Selection of row annotation variables does not match column names in original data frame.\n")
      } else {
        row_var <- row_anno_var[k]
        if (length(k) != length(row_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }


    }

    color_vec_cat_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")
    color_vec_cont_default <- c("white","black")
    if ("colorCatRow"%in%names(plot_info) && !is.null(plot_info$colorCatRow)) color_vec_cat_default <- plot_info$colorCatRow
    if ("colorContRow"%in%names(plot_info) && !is.null(plot_info$colorContRow)) color_vec_cont_default <- plot_info$colorContRow

    row_color <- matrix(nrow = length(row_var), ncol = nrow(row_info))
    if (is.null(row_anno_name)) {
        #rownames(row_color) <- paste(rownames(row_var)," ",sep="")
        rownames(row_color) <- paste(row_var," ",sep="")
    } else {
     k <- match(colnames(row_info), row_anno_var)
     k <- k[!is.na(k)]
     rownames(row_color) <- row_anno_name[k]
    }
    
    for (v in 1:length(row_var)) {
      if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5){
        color_vec <- color_vec_cont_default
      } else {
          color_vec <- color_vec_cat_default
      }
      if (!is.null(row_var_info)) {
        if (row_var[v] %in% names(row_var_info)) {
          if ("color" %in% names(row_var_info[[row_var[v]]])){
            color_vec <-  row_var_info[[row_var[v]]]$color
          }
        }
      }

    if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5) {

        varib <- row_info[ ,row_var[v]]
        if ("limit" %in% names(row_var_info[[row_var[v]]])){
            lim <-  row_var_info[[row_var[v]]]$limit
            varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
            ## 7. Ritu
            lim=lim+lim[2]+1
        } else {
            if (F) {
                varib = varib - min(varib, na.rm=T) + 1
                varib = varib / min(varib, na.rm=T)
            }
            if (T) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=(100*(varib-min(varib,na.rm=T))/x1)+1
            }

            varib <- round(varib)
            lim <- range(varib,na.rm=T)
        }

        grpUniq <- lim[1]:lim[2]
        rowColUniq <- maPalette(high=color_vec[2], low=color_vec[1], k=length(grpUniq))

        ## 7. Ritu
        #row_color[v, ] <- rowColUniq[varib]
        j=match(varib,grpUniq); j1=which(!is.na(j)); j2=j[j1]
        row_color[v,j1] <- rowColUniq[j2]

      } else {
        dat <- row_info[ ,row_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          ## 8. Ritu
          #cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
          cat("Not enough colors for ,",row_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          row_color[v, j] <- color_vec[v2]

        }
      }
    }
    RowSideColors <- row_color
      if (!is.null(row_anno_name)) {
          k=match(row_anno_name,rownames(RowSideColors))
          k=k[!is.na(k)]
          nm=rownames(RowSideColors)
          RowSideColors=RowSideColors[k,]
          if (!is.matrix(RowSideColors)) {
              RowSideColors=matrix(RowSideColors,nrow=1)
              rownames(RowSideColors)=nm
          }
      }
  } else {
    RowSideColors <- NULL
  }
  #------------------------------------------

  if (col_anno) {

    # Checks to see if col_info is a valid input
    if (class(col_info) != 'data.frame') {
      stop("col_info is meant to be a data.frame")
    }

    # Defining column annotation variable selection
    col_var <- c()

    # Looping through column annotation data frame
    if (is.null(col_anno_var)) {
      for (r in 1:ncol(col_info)) {
        if (is.numeric(col_info[ ,r]) | sum(!duplicated(col_info[ ,r])) < nrow(col_info)) {
          col_var <- c(col_var, colnames(col_info)[r])
        }
      }
    } else {
        #k=match(colnames(col_info),col_anno_var)
        #k=k[!is.na(k)]
      k=which(col_anno_var%in%colnames(col_info))
      if (length(k)==0) {
        col_var=colnames(col_info)
        cat("Selection of column annotation variables does not match column names in original data frame.\n")
      } else {
        col_var=col_anno_var[k]
        if (length(k)!=length(col_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }

    }

    color_vec_cat_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")
    color_vec_cont_default <- c("white","black")
    if ("colorCatCol"%in%names(plot_info) && !is.null(plot_info$colorCatCol)) color_vec_cat_default <- plot_info$colorCatCol
    if ("colorContCol"%in%names(plot_info) && !is.null(plot_info$colorContCol)) color_vec_cont_default <- plot_info$colorContCol

    col_color <- matrix(nrow = length(col_var), ncol = nrow(col_info))
    if (is.null(col_anno_name)) {
        #rownames(col_color) <- paste(rownames(col_color)," ",sep="")
        rownames(col_color) <- paste(col_var," ",sep="")
    } else {
        #k=match(colnames(col_info),col_anno_var)
        #if (any(is.na(k))) cat("Mismatched column variables!!!")
        #k=k[!is.na(k)]
        if (length(col_anno_var)!=length(col_anno_name)) cat("Mismatched column variables!!!")
        k=which(col_anno_var%in%colnames(col_info))
        rownames(col_color) <- col_anno_name[k]
    }
    
    for (v in 1:length(col_var)) {
      if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {
        color_vec <- color_vec_cont_default
      } else {
          color_vec <- color_vec_cat_default
      }
      if (!is.null(col_var_info)) {
        if (col_var[v] %in% names(col_var_info)) {
          if ("color" %in% names(col_var_info[[col_var[v]]])) {
            color_vec <-  col_var_info[[col_var[v]]]$color
          }
        }
      }

      if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {

        varib <- col_info[ ,col_var[v]]
        if ("limit" %in% names(col_var_info[[col_var[v]]])){
            if (F) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=((varib-min(varib,na.rm=T))/x1)+1
                lim <-  col_var_info[[col_var[v]]]$limit+1
            } else {
                lim <-  col_var_info[[col_var[v]]]$limit
                varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
                lim=lim+lim[2]+1
            }
        } else {
            if (F) {
                varib = varib - min(varib, na.rm=T) + 1
                varib = varib / min(varib, na.rm=T)
            }
            if (T) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=(100*(varib-min(varib,na.rm=T))/x1)+1
            }
            varib <- round(varib)
            lim <- range(varib,na.rm=T)
        }

        grpUniq=lim[1]:lim[2]
        colColUniq=maPalette(high=color_vec[2],low=color_vec[1],k=length(grpUniq))

        j=match(varib,grpUniq);j1=which(!is.na(j)); j2=j[j1]
        col_color[v,j1] <- colColUniq[j2]
      } else {
        dat <- col_info[ ,col_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          col_color[v,j] <- color_vec[v2]
        }
      }
    }
    ColSideColors <- col_color
    if (!is.null(col_anno_name)) {
        k=match(col_anno_name,rownames(ColSideColors))
        k=k[!is.na(k)]
        nm=rownames(ColSideColors)
        ColSideColors=ColSideColors[k,]
        if (!is.matrix(ColSideColors)) {
            ColSideColors=matrix(ColSideColors,nrow=1)
            rownames(ColSideColors)=nm
        }
    }
  } else {
    ColSideColors <- NULL
  }
  #--------------------------------------------------------------------------------------------
  # Global Plot Info
  nc <- ncol(x)
  nr <- nrow(x)

  margins=c(5,5)
  cexColSide <-  1
  cexRowSide <-  1
  cexCol <- 0.2 + 1 / log10(nc)
  cexRow <- 0.2 + 1 / log10(nr)

  if (!(is.null(plot_info))) {
    if ("margins" %in% names(plot_info)){
      margins <- plot_info$margins
    }
    if ("cexRowSide" %in% names(plot_info)) {
      cexRowSide <- plot_info$cexRowSide
    }
    if ("cexColSide" %in% names(plot_info)) {
      cexColSide <- plot_info$cexColSide
    }
    if ("cexCol" %in% names(plot_info)) {
      cexCol <- plot_info$cexCol
    }
    if ("cexRow" %in% names(plot_info)){
      cexRow <- plot_info$cexRow
    }
  }

  #--------------------------------------------------------------------------------------------
  ## Labels
  row_lab <- row_lab[1]

  if (row_lab) {
    if(!(is.null(row_lab_vtr))) {
      labRow <- row_lab_vtr
    } else {
      labRow <- rownames(x)
    }
  }
  else {
    labRow <- NA
  }
  #------------------------------------------
  col_lab <- col_lab[1]

  if (col_lab) {
    if(!(is.null(col_lab_vtr))){
      labCol = col_lab_vtr
    } else {
      labCol <- colnames(x)
    }
  }
  else {
    labCol <- NA
  }
  
  #--------------------------------------------------------------------------------------------
  ## Dendograms
  row_dend <- row_dend[1]

  if (row_dend) {
    if (is.null(row_clust) || class(row_clust) %in% c("dendogram", "hclust")) {
      Rowv <- row_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Rowv <- NA
  }
  #------------------------------------------
  col_dend <- col_dend[1]

  if (col_dend) {
    if (is.null(col_clust) || class(col_clust)%in%c("dendogram", "hclust")) {
      Colv <- col_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Colv <- NA
  }
  #--------------------------------------------------------------------------------------------
  ## Legend
  heatmapColorBar.my <- function(zlm=c(-.5,.5),cols=c("green","red","black"),main=NULL) {
      if (length(cols)==3) {
          try <- maPalette(high=cols[1], low=cols[2], mid=cols[3])
      } else {
          ## 5. Ritu
          try <- maPalette(high=cols[1], low=cols[2])
      }
      maColorBar(try, scale=zlm,main=main)
  }
  sampleColorLegend.my <- function(tls,col=NULL,lty=NULL,legendTitle=NULL,cex=NULL,density=NULL) {
    nTypes <- length(tls)
    if (is.null(col)) {
      cl <- brewer.pal(8, "Accent")
      cl <- cl[1:min(nTypes,length(cl))]
      if (length(cl)<nTypes) {
        cl=c(brewer.pal(nTypes,"Set3"),brewer.pal(nTypes,"Set2"))[1:nTypes]
        cl[1] <- "#1F78B4"
        if (length(cl)>8) {
          cl[9] <- "#999999"
        }
      }
      cl <- cl[1:nTypes]
      cl[cl=="#FFFF99"]="#FFFF60"
    } else {
      cl <- col
    }
    fill=col=NULL
    if (is.null(lty)) {
      fill=cl
    } else {
      col=cl
    }
    n <- length(tls)
    if (n!=0) {
        ii <- 1:length(tls)
        if (is.null(cex)) {
          cex=ifelse(max(nchar(tls))>13,1.5,3)
          if (nTypes>6) {cex=1.5}
        }
        plot(0:length(tls),0:length(tls),type="n",axes=F,xlab="",ylab="")
        if (is.null(lty)) {
          if (is.null(density)) {
            legend(0,length(tls),tls,fill=fill,col=col,lty=lty,cex=cex,title=legendTitle)
          } else {
            ## 6. Ritu
            legend(0,length(tls),tls,col=fill,lty=lty,cex=cex,density=density,title=legendTitle)
            if (F) {
              text(1,k-1,legendTitle)
              for (k in 1:length(tls)) {
                rect(0,k-0.5,1,k+0.5,col=fill[k],density=density)
                text(2,k,tls[k])
              }
            }
          }
        } else {
          legend(0,length(tls),tls,col=col,lty=lty,cex=cex,title=legendTitle)
        }
    }
  }
  #--------------------------------------------------------------------------------------------
  ## Output Files
  if (!is.null(file_name)){

    element <- strsplit(file_name, ".", fixed = TRUE)

    if (element[[1]][2] == "pdf") {
      pdf(file_name, paper = "letter")
    }
    else if (element[[1]][2] == "jpeg") {
      jpeg(filename = file_name)
    }
    else if (element[[1]][2] == "png") {
      png(filename = file_name)
    }
    else if (element[[1]][2] == "tiff") {
      tiff(filename = file_name)
    }
    else {
      stop("File name not in valid format: filename.type")
    }
  }
  #--------------------------------------------------------------------------------------------
  cols <- heatmap_color
  
  ## Heatmap Output
  clusterObj=heatmap4(x = x, Rowv = Rowv, Colv = Colv, symm = FALSE,
           ColSideColors = ColSideColors, RowSideColors = RowSideColors, labCol = labCol, labRow = labRow,
           scale = "none", na.rm = FALSE, margins = margins, main = h_title, xlab = NULL, ylab = NULL,
           high = cols[1], low = cols[2], mid = cols[3], cexRowSide = cexRowSide, cexColSide = cexColSide, cexRow = cexRow,
           cexCol = cexCol, zlm=zlm, ...)
  ## Legend Output
  if (input_legend) {
      #cat("Legends not yet implemented ....")
      if (T) {
          cat("zlm:",exists("zlm"),"\n")
          if (!exists("zlm")) zlm=c(-.5,.5)
          ## 9. Ritu
          #heatmapColorBar(cols=cols,limit=zlm)
          heatmapColorBar(cols=cols,limit=zlm,k=5)
          if (input_legend & row_anno) {
              for (vId in 1:length(row_var))
            sampleColorLegend(tls = row_var, col = row_color, lty = NULL, legendTitle = legend_title, cex = NULL)
          }
          if (input_legend & row_anno) {
            cat("Legends ....")
            for (vId in 1:length(row_var)) {
                nm=sub("^ +","",sub(" +$","",rownames(row_color)[vId]))
                x=sort(unique(row_info[,row_var[vId]]))
                color_vec <- color_vec_cat_default
                if (!is.null(row_var_info)) {
                  if (row_var[vId] %in% names(row_var_info)) {
                    if ("color" %in% names(row_var_info[[row_var[vId]]])) {
                      color_vec <-  row_var_info[[row_var[vId]]]$color
                    }
                  if ("level" %in% names(row_var_info[[row_var[vId]]])) {
                    x <-  row_var_info[[row_var[vId]]]$level
                  }
                  }
                }
                sampleColorLegend(tls=x,col=color_vec,lty=NULL,legendTitle=nm,cex=NULL)
            }
          }
          if (input_legend & col_anno) {
            cat("Legends ....")
            for (vId in 1:length(col_var)) {
                nm=sub("^ +","",sub(" +$","",rownames(col_color)[vId]))
                if (is.numeric(col_info[ ,col_var[vId]]) & length(unique(col_info[ ,col_var[vId]])) > 5) {
                    varib <- col_info[ ,col_var[vId]]
                    color_vec <- color_vec_cont_default
                    if ("limit" %in% names(col_var_info[[col_var[vId]]])){
                        lim <-  col_var_info[[col_var[vId]]]$limit
                        varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
                    } else {
                        x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                        varib=(100*(varib-min(varib,na.rm=T))/x1)+1
                        varib <- round(varib)
                        lim <- range(varib,na.rm=T)
                        lim <- round(range(col_info[ ,col_var[vId]],na.rm=T),2)
                    }
                    color_vec=rev(color_vec)
                    heatmapColorBar(cols=color_vec,limit=lim)

                } else {
                    x=sort(unique(col_info[,col_var[vId]]))
                    color_vec <- color_vec_cat_default
                    if (!is.null(col_var_info)) {
                      if (col_var[vId] %in% names(col_var_info)) {
                        if ("color" %in% names(col_var_info[[col_var[vId]]])) {
                          color_vec <-  col_var_info[[col_var[vId]]]$color
                        }
                      if ("level" %in% names(col_var_info[[col_var[vId]]])) {
                        x <-  col_var_info[[col_var[vId]]]$level
                      }
                      }
                    }
                    sampleColorLegend(tls=x,col=color_vec,lty=NULL,legendTitle=nm,cex=NULL)
                }
            }
          }
          # sampleColorLegend(tls = c("N0", "N+"), col = samColUniq[1:2], lty = NULL, legendTitle = "Node", cex = NULL)
          # tls = title, each annotation variable, default: used annotation variables, for loop
          # col = color, default: annotation default or specified by user
          # lty = line type, deafault = NULL
          # legendTitle, default = NULL
          # cex = text size, default = NULL
      }
  }

  #--------------------------------------------------------------------------------------------
  ## Clears graphics on device
  if (!is.null(file_name)){
    dev.off()
  }
  
  invisible(clusterObj)

}



##  2. Ritu 03/28/06 If ColSideColors==NULL, one doesn''t have to specify phenotype color labels
##  3. Ritu 04/14/06 If RowSideColors==NULL, one doesn''t have to specify chr color bar
##  4. Ritu 04/14/06 Can use 1 col matrix too
##  5. Ritu 04/14/06 If totalC!=nc, image will be w.r.t totalC instead of using whole window
##  6. Ritu 07/19/06 Can use 1 row phenotype color labels
##  7. Ritu 08/24/06 adjust margins
##  8. Ritu 07/05/07 Make amplifications smaller
##  9. Ritu 03/18/08 If totalC!=nc, column color bars will be w.r.t totalC instead of using whole window
##                Not perfect for column dendrogram
## 10. Ritu 04/28/08 RowSideColors==NULL option which was not working before is now fixed
## 11. Ritu 08/30/09 New option RowSideColors as a matrix
## 12. Ritu 01/14/10 New option cexAmp
## 13. Ritu 02/08/11 Returns the cluster objects
## 14. Ritu 03/31/11 Returns cluster objects only if they exist
## 15. Ritu 02/17/12 Draw lines on heatmap
## 16. Ritu 03/27/13 Delineate clusters. Specify params ncr, ncc. Rowv, Colv have to be hclust objects if ncr, ncc are specified
## 17. Ritu 12/05/13 New param font for label
## 18. Ritu 12/05/13 Row cluster delineation was not working - too many delineations. Needed modified function rect.hclust.my
## 19. Ritu 01/22/16 New option addText
## 20. Ritu 02/17/16 Can specify exact colors to use for heatmap. Use param high. If length of high > 1 then mid & mid will be ignored
## 21. Ritu 05/17/16 Default linkage method set to ward.D
## 22. Ritu 05/30/16 New option lineColor
## 23. Ritu 08/28/16 Modified addText to display word instead of character. New option cexText
## 24. Ritu 01/27/18 New options lwidRowSide - row side width, lheiColSide - column side height, cexRowSide - row side font size, cexColSide - column side font size, densColor - to shade row/column side missing values
## 25. Ritu 03/27/19 New options sideLabRow - row label side, sideLabCol - column label side
## 26. Ritu 05/12/20 New params layoutRespect, sideColSide, sideRowSide
## 27. Ritu 05/26/20 If totalR!=nr, row color bars will be w.r.t totalR instead of using whole window
##                   lwidHeatmap, lheiHeatmap
## 28. Ritu 12/17/20 Fixed problem of ordering of column and row labels when labRow and labCol are not provided
## 29. Ritu 12/17/20 Return cluster designations
## 30. Ritu 02/02/21 Reorder hclust object when dendrogram object is reordered

## 27. Ritu
heatmap4 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,
hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),
scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,
cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",
totalR=nr, totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),
methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",
addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidHeatmap=4, lheiHeatmap=4, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, sideLabRow=4, sideLabCol=1, layoutRespect=T, sideColSide=c("left","right"), sideRowSide=c("bottom","top"), ...)
### 26. Ritu
#heatmap4 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, sideLabRow=4, sideLabCol=1, layoutRespect=T, sideColSide=c("left","right"), sideRowSide=c("bottom","top"), ...)
#### 25. Ritu
##heatmap4 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, sideLabRow=4, sideLabCol=1, ...)
##### 24. Ritu
###heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, ...)
###### 23. Ritu
####heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, ...)
####### 22. Ritu
#####heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, ...)
######## 21. Ritu
######heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist, hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL,totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, ...)
######## 19. Ritu
#######heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL,totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward", methodC = "ward", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, ...)
######### 17. Ritu
#######heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL,totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),methodR = "ward", methodC = "ward", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, ...)
########## 16. Ritu
########heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist, hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"), scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors, cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL,totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"), methodR = "ward", methodC = "ward", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, ...)
#########heatmap3 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist, hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"), scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors, cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL,totalC=nc, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"), methodR = "ward", methodC = "ward", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",addamps=NULL, colamps=NULL, cexAmp=.25, ...)
{
    
    
    #print("heatmap4: zlm")
    #print(zlm)
    
    ## 4. Ritu
    if (!is.matrix(x)) {f
        x <- matrix(x,ncol=1)
        if (!is.null(addamps)) {
            addamps <- matrix(addamps,ncol=1)
        }
        ## 19. Ritu
        if (!is.null(addText)) {
            addText <- matrix(addText,ncol=1)
        }
    }
    scale <- if (symm && missing(scale)) "none" else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) stop("`x' must be a numeric matrix")
    nr <- di[1]
    nc <- di[2]
    ## 27. Ritu
    sideRowSide=sideRowSide[1]
    sideColSide=sideColSide[1]
    ## 4. Ritu
    #if (nr <= 1 || nc <= 1) stop("`x' must have at least 2 rows and 2 columns")
    if (nr <= 1 || nc < 1) stop("`x' must have at least 2 rows and 1 column")
    if (!is.numeric(margins) || length(margins) != 2) stop("`margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (is.null(Rowv)) Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "hclust")) {
            ## 16. Ritu
            hcr <- Rowv
            ddr <- as.dendrogram(hcr)
        } else if (inherits(Rowv, "dendrogram"))
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x), method = methodR)
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) {
                ddr <- reorder(ddr, Rowv)
                ## 30. Ritu
                hcr <- as.hclust(ddr)
            }
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) stop("row dendrogram ordering gave index of wrong length")
    } else rowInd <- 1:nr
    if (doCdend) {
        if (inherits(Colv, "hclust")) {
            ## 16. Ritu
            hcc <- Colv
            ddc <- as.dendrogram(hcc)
        } else if (inherits(Colv, "dendrogram"))
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) x else t(x)), method = methodC)
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) {
                ddc <- reorder(ddc, Colv)
                ## 30. Ritu
                hcc <- as.hclust(ddc)
            }
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) stop("column dendrogram ordering gave index of wrong\nlength")
    } else colInd <- 1:nc
    ## 28. Ritu
    if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr) else rownames(x)
    if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc) else colnames(x)
    x <- x[rowInd, colInd]
    ## 28. Ritu
    #if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr)[rowInd] else rownames(x)
    #if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc)[colInd] else colnames(x)
    if (scale == "row") {
        x <- sweep(x, 1, rowMeans(x, na.rm = na.rm))
        sx <- apply(x, 1, sd, na.rm = na.rm)
        x <- sweep(x, 1, sx, "/")
    } else if (scale == "column") {
        x <- sweep(x, 2, colMeans(x, na.rm = na.rm))
        sx <- apply(x, 2, sd, na.rm = na.rm)
        x <- sweep(x, 2, sx, "/")
    }
    lmat <- rbind(c(NA, 3), 2:1)
    #lwid <- c(if (doRdend) 1 else 0.05, 4)
    #lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 4)

    ## 27. Ritu
    ### 7. Ritu
    ##lwid <- c(1, 4)
    ##lhei <- c(1 + if (!is.null(main)) 0.2 else 0, 4)
    #lwid <- c(ifelse(doRdend,1,0.01), 4)
    #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), 4)
    lwid <- c(ifelse(doRdend,1,0.01), lwidHeatmap)
    lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), lheiHeatmap)

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
           # if (!is.character(ColSideColors) || length(ColSideColors) !=
            #    nc)
              #  stop("'ColSideColors' must be a character vector of\nlength ncol(x)")

            ## 6. Ritu
            if (!is.matrix(ColSideColors)) {
                ColSideColors <- matrix(ColSideColors,nrow=1)
                rownames(ColSideColors) <- ""
            }

        ## 11. Ritu
        #lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lmat <- rbind(lmat[1, ] + 1, c(rep(NA, ncol(lmat) - 1),1), lmat[2, ] + 1)

        ## 24. Ritu
        lhei <- c(lhei[1], 0.2, lhei[2])
    }
    ## 3. Ritu
    if (!is.null(RowSideColors)) {
        #if (!missing(RowSideColors)) {
            #if (!is.character(RowSideColors) || length(RowSideColors) != nr)
            #    stop("'RowSideColors' must be a character vector of\nlength nrow(x)")
            #lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
            #lwid <- c(lwid[1], 0.2, lwid[2])

        ## 11. Ritu
        if (!is.matrix(RowSideColors)) {
            RowSideColors <- matrix(RowSideColors,nrow=1)
            rownames(RowSideColors) <- ""
        }
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
        ## 24. Ritu
        #lwid <- c(lwid[1], 0.2, lwid[2])
        lwid <- c(lwid[1], lwidRowSide, lwid[2])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

################################
#redo lmat:

    ## 1. Ritu
    #if (!is.matrix(ColSideColors)) {
        #ColSideColors <- matrix(ColSideColors,nrow=1,dimnames=list(names(ColSideColors),1:nc))
    #}

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        nr.my=nrow(ColSideColors)+2

        ## 11. Ritu
        #nc.my=3
        #nfig=nr.my+2
        #lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        #lmat[nr.my,]=c(nfig-1,1,nfig-2)
        #lmat[1, nc.my]=nfig
        #lmat[2:(nr.my-1),nc.my]=(nfig-3):2
        nc.my=2+ifelse(is.null(RowSideColors),0,nrow(RowSideColors))
        nfig=nr.my+nc.my-1
        lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        if (is.null(RowSideColors)) {
            lmat[nr.my,]=c(nfig-1,nfig-2)
        } else {
            lmat[nr.my,]=c(nfig-1,1:nrow(RowSideColors),nfig-2)
            ## 27. Ritu
            ## 24. Ritu
            ##lwid <- c(ifelse(doRdend,1,0.01), rep(.2, nrow(RowSideColors)), 4)
            #lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), 4)
            lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), lwidHeatmap)
        }
        lmat[1, nc.my]=nfig
        lmat[2:(nr.my-1),nc.my]=(nfig-3):(nc.my-1)

        ## 11. Ritu
        ### 10. Ritu
        #if (is.null(RowSideColors)) {
        #    lmat=lmat[,c(1,3:ncol(lmat))]
        #    lmat=lmat-1
        #    lmat[lmat==(-1)]=0
        #}

        ## 27. Ritu
        ### 24. Ritu
        #### 7. Ritu
        ###lhei=c(1, rep(.2, nrow(ColSideColors)),4)
        ##lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(ColSideColors)), 4)
        #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(lheiColSide, nrow(ColSideColors)), 4)
        lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,lheiColSide), rep(lheiColSide, nrow(ColSideColors)), lheiHeatmap)
    }
    
    notRequired=function(x) {
        ## 11. Ritu
        if (!is.null(RowSideColors)) {
            nr.my=nrow(RowSideColors)+2
            nc.my=nrow(ColSideColors)+2
            nfig=nr.my+2
            lmat=matrix(0, nrow=nr.my, ncol=nc.my)
            lmat[nr.my,]=c(nfig-1,1,nfig-2)
            lmat[1, nc.my]=nfig
            lmat[2:(nr.my-1),nc.my]=(nfig-3):2
            if (is.null(ColSideColors)) {
                lmat=lmat[,c(1,3:ncol(lmat))]
                lmat=lmat-1
                lmat[lmat==(-1)]=0
            }
            lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(RowSideColors)), 4)
        }
    }

###################################
    op <- par(no.readonly = TRUE)
    on.exit(par(op))
    if (verbose) {
        cat("Final layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

    ## 26. Ritu
    ##layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    #layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = layoutRespect)
    #layout.show(layoutThis)
    #layout.show(n=nfig)

    ## 3. Ritu
    if (!is.null(RowSideColors)) {
    #if (!missing(RowSideColors)) {
        par(mar = c(margins[1], 0, 0, 0.5))

        ## 11. Ritu
        #if (revC) {
        #    image(rbind(1:nr), col = RowSideColors[rev(rowInd)], axes = FALSE)
        #} else {
        #    image(rbind(1:nr), col = RowSideColors[rowInd], axes = FALSE)
        #}
        if (revC) {
            j=rev(rowInd)
        } else {
            j=rowInd
        }
        for (i in 1:nrow(RowSideColors)) {
            ## 27. Ritu
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            ##image(rbind(1:nr), z=rbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            ##image(cbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(RowSideColors[i,j]))) {
                    for (jj in which(is.na(RowSideColors[i,j]))) {
                        rect(-1,jj-0.5,1,jj+0.5,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ### 24. Ritu
            ##mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=1)
            #mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
            mtext(side=ifelse(sideRowSide=="bottom",1,3), text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
        }
    }
    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2]))
        for (i in 1:nrow(ColSideColors)) {
            ## 9. Ritu
            #image(cbind(1:nc), col = ColSideColors[i,colInd], axes = FALSE)
            image(cbind(1:nc), z=cbind(1:nc),col = ColSideColors[i,colInd], axes = FALSE, xlim = 0.5 + c(0, totalC))
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(ColSideColors[i,colInd]))) {
                    for (jj in which(is.na(ColSideColors[i,colInd]))) {
                        rect(jj-0.5,-1,jj+0.5,1,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ## 24. Ritu
            #mtext(side=2, text=as.character(rownames(ColSideColors)[i]), las=1, cex=1)
            mtext(side=ifelse(sideColSide=="left",2,4), text=as.character(rownames(ColSideColors)[i]), las=1, cex=cexColSide)
        }
    }
    par(mar = c(margins[1], 0, 0, margins[2]))
    if (!symm || scale != "none")
        x <- t(x)
    if (revC) {
        iy <- nr:1
        ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1:nr
    x.floor <- x
    for (i in 1:ncol(x)) {
        ind1 <- (1:length(x[, i]))[x[, i] >= zlm[2] & !is.na(x[,i])]
        ind2 <- (1:length(x[, i]))[x[, i] <= zlm[1] & !is.na(x[,i])]
        x.floor[, i][ind1] <- rep((zlm[2] - 0.01), length(ind1))
        x.floor[, i][ind2] <- rep((zlm[1] + 0.01), length(ind2))
    }
    ## 5. Ritu
    #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, nc), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
    if (length(high)>1) {
        ## 20. Ritu
        colThis=high
    } else {
        colThis=maPalette(high = high, low = low, mid = mid)
    }
    if (nc==1) {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    } else {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    }
    ## 15. Ritu
    if (!is.null(lineCol)) {
        ## 22. Ritu
        #abline(v=lineCol)
        abline(v=lineCol,col=lineColor)
    }
    ## 15. Ritu
    if (!is.null(lineRow)) {
        ## 27. Ritu
        ### 22. Ritu
        ##abline(h=lineRow)
        #abline(h=lineRow,col=lineColor)
        for (i in lineRow) lines(x=c(1-0.5,nc+0.5),y=rep(i,2), col=lineColor)
    }

##################

## 19. Ritu
if (!is.null(addText)) {
    addText=addText[rowInd, colInd]
    if (!is.matrix(addText)) {
        addText <- matrix(addText,ncol=1)
    }
    for (i in 1:ncol(addText)) {
        j=which(!is.na(addText[,i]))
        ## 23. Ritu
        #points(rep(i, length(j)), j, pch=addText[j,i])
        if (length(j)!=0) text(i, j, labels=addText[j,i], cex=cexText)
    }
}

if (!is.null(addamps)) {
    addamps=addamps[rowInd, colInd]
    ## 4. Ritu
    if (!is.matrix(addamps)) {
        addamps <- matrix(addamps,ncol=1)
    }
    for (i in 1:ncol(addamps)) {
        amp=which(addamps[,i]>0)
        ## 12. Ritu
        ### 8. Ritu
        ##points(rep(i, length(amp)), amp, col=colamps, cex=.75, pch=20)
        #points(rep(i, length(amp)), amp, col=colamps, cex=.25, pch=20)
        points(rep(i, length(amp)), amp, col=colamps, cex=cexAmp, pch=20)
    }
 }
    
################

    ## 25. Ritu
    ### 17. Ritu
    ##axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
    #axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    axis(sideLabCol, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    if (!is.null(xlab))
        mtext(xlab, side = 1, line = margins[1] - 1.25)
    ## 25. Ritu
    ### 17. Ritu
    ##axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
    #axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    axis(sideLabRow, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    if (!is.null(ylab))
        mtext(ylab, side = 4, line = margins[2] - 1.25)
    if (!missing(add.expr))
        eval(substitute(add.expr))
    ## 27. Ritu
    #par(mar = c(margins[1], 0, 0, 0))
    xr=ifelse(totalR==nr,margins[1],2*(totalR-nr)+1+margins[1])
    xc=0
    par(mar = c(xr, 0, 0, xc))
    if (doRdend) {
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcr") & !is.na(ncr)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcr,k=ncr) else stop("Must be of class hclust to delineate clusters")
            if (class(hcr)=="hclust") rect.hclust.my(hcr,k=ncr,horiz=TRUE) else stop("Must be of class hclust to delineate clusters")
        }
    } else {
        frame()
    }
    ## 27. Ritu
    ## 9. Ritu
    #if (totalC==nc) {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2]))
    #} else {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, 2*(totalC-nc)+1+margins[2]))
    #}
    xr=0
    xc=ifelse(totalC==nc,margins[2],2*(totalC-nc)+1+margins[2])
    par(mar = c(xr, 0, if (!is.null(main)) 1 else 0, xc))
    if (doCdend) {
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcc") & !is.na(ncc)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
            if (class(hcc)=="hclust") rect.hclust.my(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
        }
    } else if (!is.null(main)) {
        frame()
    }
    if (!is.null(main)) {
        ## 27. Ritu
        if (doCdend) {
            title(main, cex.main=0.8 * op[["cex.main"]])
            #text(x=20,y=5,main,cex=1 * op[["cex.main"]],font=2)
        } else {
            text(x=0.5,y=0.5,main,cex=1.5 * op[["cex.main"]],font=2)
        }
        #title(main, cex.main = 1.5 * op[["cex.main"]])
        #title(main, cex.main = 1.5 * op[["cex.main"]],line = margins[1] - 1.25)
        #plot(1,type="n",xaxt="n",yaxt="n",xlab="",ylab="");
        #text(x=10+margins[1] - 1.25,y=1,"test",cex=1.5 * op[["cex.main"]],)
        #text(x=1,y=1,c("test","ok"),cex=1.5 * op[["cex.main"]])
        #text(x=0.5,y=1,c("tex"),cex=1.5 * op[["cex.main"]])
        #points(rep(0,10),1:10)
    }

    ## 13. Ritu
    #invisible(list(rowInd = rowInd, colInd = colInd))
    out=list(rowInd = rowInd, colInd = colInd, rowClust=NULL, colClust=NULL)

    ## 14. Ritu
    #if (doRdend) out$rowClust=hcr
    #if (doCdend) out$colClust=hcc
    if (exists("hcr")) out$rowClust=hcr
    if (exists("hcc")) out$colClust=hcc
    
    ## 29. Ritu
    if (exists("hcr") & !is.na(ncr)) {
        y=cutree(hcr,ncr)
        y=y[out$rowInd]
        out$rowClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncr) {
            out$rowClustId[which(y==y[k1[k]])]=k
        }
    }
    if (exists("hcc") & !is.na(ncc)) {
        y=cutree(hcc,ncc)
        y=y[out$colInd]
        out$colClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncc) {
            out$colClustId[which(y==y[k1[k]])]=k
        }
    }

    invisible(out)
}

rect.hclust.my=function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL, horiz = FALSE) {
    if (length(h) > 1L | length(k) > 1L) stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k))
        stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    } else if (is.null(k)) {
        stop("specify exactly one of 'k' and 'h'")
    }
    if (k < 2 | k > length(tree$height))
    stop(gettextf("k must be between 2 and %d", length(tree$height)), domain = NA)
    if (is.null(cluster))
    cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which))
        stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which))
    which <- 1L:k
    if (any(which > k))
    stop(gettextf("all elements of 'which' must be between 1 and %d", k), domain = NA)
    border <- rep_len(border, length(which))
    retval <- list()
    for (n in seq_along(which)) {
        if (horiz) {
            ## 18. Ritu
            rect(mean(rev(tree$height)[(k - 1):k]), m[which[n]] + 0.66, par("usr")[2L], m[which[n] + 1] + 0.33, border = border[n])
        } else {
            rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
        }
#        rect(xleft, ybottom, xright, ytop, density = NULL, angle = 45,col = NA, border = NULL, lty = par("lty"), lwd = par("lwd"),
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}

######################################################################
######################################################################
######################################################################


script <- function() {
library(RColorBrewer)
library(marray)
library(sma)
library(aCGH)

#row colors (chromosomes)

chrominfo=human.chrom.info.Jul03
clinfo <- clones.info(tumor.acgh)
chromcols <- rep(NA, nrow(clinfo))

for (i in 1:23)
{
    if (is.odd(i))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "yellowgreen"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "green"
        chromcols[which(clinfo$Chrom==i)] <- "gray10"
        
    }
    else if (!(is.odd(i)))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "skyblue"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "blue"
        chromcols[which(clinfo$Chrom==i)] <- "gray90"
        
    }
}

sampnm1 <- sample.names(tumor.acgh)[ind.match.tumor]

ind.samp <- which(!is.na(ind.match.tumor))
ind.cl=which(clinfo$Chrom<=23 & clinfo$Clone!="RMC01P009")

#create color bars accoridng to clinical variables

sampCols=matrix(NA, nrow=7, ncol=nrow(phenData))

#expression subtype

rsp=as.numeric(phenData$subCor)
tmp=brewer.pal(length(unique(rsp[!is.na(rsp)])),"Accent")

sampcols <- rep(NA, length(rsp))
for (i in 1:length(tmp))
{
    sampcols[which(rsp==i)]=tmp[i]
}
sampcols[which(sampcols=="#FFFF99")]="yellow2"
sampCols[1,]=sampcols

#pr
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$pr=="pos")]=1
rsp[which(phenData$pr=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[2,]=sampcols

#er
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$er=="pos")]=1
rsp[which(phenData$er=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[3,]=sampcols

#p53
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$p53==0)]=1
rsp[which(phenData$p53==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[4,]=sampcols

#ki67

rsp=I(phenData$ki67>10)
rsp[which(rsp==TRUE)]=2
rsp[which(rsp==FALSE)]=1

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[5,]=sampcols

#size

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$size<=median(phenData$size, na.rm=T))]=1
rsp[which(phenData$size>median(phenData$size, na.rm=T))]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[6,]=sampcols

#nodal.status

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$nodal.status==0)]=1
rsp[which(phenData$nodal.status==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[7,]=sampcols

########################

rownames(sampCols)=c("Expression subtype", "PR status", "ER status", "p53 status", "ki67 status", "size", "nodal status")

#########################

#main data (smoothed with outliers)
tmp <- tumor.smoothed.impute.aber$aber.val[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

#amplifications to be added as yellow dots
tmpamp <- tumor.amplif[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

postscript("try.ps", paper="letter")
try10=heatmap3(x=tmp[,ind.samp], Rowv=NA, Colv=NULL, distfun = dist.cor.func, hclustfun = hclust,  symm=F, ColSideColors = sampCols[,ind.samp], RowSideColors=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))], labCol=as.character(sampnm1)[ind.samp], labRow=NA, scale="none", na.rm = F, margins = c(5, 5), main = NULL, xlab = NULL, ylab = NULL, zlm=c(-.5,.5), addamps=tmpamp[,ind.samp], colamps="yellow")
dev.off()
}



```


## 3. Example Data

We will use the data sets genomDat, phen, and anno to map and generate column and row annotations. 

The data set genomDat is 2x2 matrix with gene expression data (subjects, genes). The phen (phenotype) data set displays the clinical information of the subject. The anno data set consists of gene mapping information.

```{r}
# Load the rda file from the package to access the data sets
load(file = 'data_gen.rda') 
```

```{r, include = FALSE}

genomDat <- as.matrix(genomDat[1:20,1:20])

# Column annotation df

col<- select(phen, age_year, sex)
col_rows <- ncol(col)
col_columns <- 2
phen <- as.data.frame(col)
colnames(phen) <- c("age","sex")


# Row annotation df
row<-as.matrix(table(anno$Chrom))
row_rows <- nrow(table(anno$Chrom))
row_columns <- 1
anno <- matrix(data = row)
anno <- as.data.frame(anno)
colnames(anno)<- c("chrom")

```

```{r}
# Sample portion of genomDat (heatmap examples will use [1:20,1:20])
print(genomDat[1:9,1:6])

# Sample portion of phen (heatmap examples will use [1:39]) 
print(phen[1:2,1:2])

# Sample portion of anno (heatmap examples will use [1:22])
print(anno[1:1,1:1])

```


## 4. Generate Heatmap 

```{r}
# Default heatmap 
generate_heatmap(genomDat)
```

```{r}
# Heatmap with column dendrogram
generate_heatmap(genomDat, col_dend = TRUE)
```

```{r}
# Heatmap with column dendrogram, column annotations    
generate_heatmap(genomDat, col_info = phen, col_dend = TRUE, col_anno = TRUE)
```

```{r}
# Heatmap with column dendrogram, column annotations, column label   
generate_heatmap(genomDat, col_lab = TRUE, col_info = phen, 
col_anno = TRUE, col_dend = TRUE, plot_info = list(margins = c(2,2)))
```

```{r}
# Heatmap with all annotations
generate_heatmap(genomDat, col_lab = TRUE, row_lab = TRUE, col_anno = TRUE, 
row_anno = TRUE, col_info = phen, row_info = anno, col_dend = TRUE, 
row_dend = TRUE, plot_info = list(margins = c(5,5)))
```

## 5. More
```{r}
# Add a title 
generate_heatmap(genomDat, col_lab = TRUE, row_lab = TRUE, col_anno = TRUE, 
row_anno = TRUE, col_info = phen, row_info = anno, col_dend = TRUE, 
row_dend = TRUE, h_title = "Genome Heatmap", plot_info = list(margins = c(5,5)))
```

```{r}
# Change plot and annotation colors and font size  
main_plot = list("cexCol" = 1.25, "cexRow" = 1.5, "cexRowSide" = 1, "cexColSide" = 1 )
cate_color = list(age = list(color = c("light blue", "blue")), chrom = list(color = c("pink",
"purple")))

generate_heatmap(genomDat, col_lab = TRUE, row_lab = TRUE, col_anno = TRUE, row_anno = TRUE,
col_info = phen, row_info = anno, col_dend = TRUE, row_dend = TRUE, 
col_anno_var = c("age","sex"), row_anno_var = c("chrom"), h_title = "Genome Heatmap", 
plot_info = main_plot, heatmap_color =c("light blue","purple","pink"), col_var_info = cate_color, 
row_var_info = cate_color)
```

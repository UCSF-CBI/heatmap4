---
title: "heatmap4 Vignette"
author: "Rohan Bhanot"
date: "10/31/2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Heatmap Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Introduction
This package takes the original heatmap function and reduces the argument complexity. 

A heat map is a false color image (basically image(t(x))) with a dendrogram added to the left side and to the top. Typically, reordering of the rows and columns according to some set of values (row or column means) within the restrictions imposed by the dendrogram is carried out.


```{r, echo=FALSE}
if (F) {
  ## Calling Bioconductor
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

  BiocManager::install("marray")
  load("../data.RData")
}
```

## 2. Loading Libraries

The libraries to call are the following:

```{r}
library(RColorBrewer)
library(marray)
```

```{r include=FALSE}
source("./Heatmap4source.Rhtml")
## Wrapped heatmap function
generate_heatmap <- function(x, col_lab = c(TRUE, FALSE), row_lab = c(TRUE, FALSE), col_lab_vtr = NULL,
                             row_lab_vtr = NULL, col_anno = c(TRUE, FALSE), row_anno = c(TRUE, FALSE), col_info = NULL,
                             row_info = NULL, col_anno_var = NULL, row_anno_var = NULL, col_var_info = NULL,
                             row_var_info = NULL, col_dend = c(TRUE, FALSE), row_dend = c(TRUE, FALSE),
                             # review col/row_clust and _dend
                             col_clust = NULL, row_clust = NULL,
                             plot_info = c("cexCol" = NULL, "cexRow" = NULL, "cexColSide" = NULL, "cexRowSide" = NULL),
                             file_name = NULL, h_title = NULL, ...)
{

  #--------------------------------------------------------------------------------------------
  ## Annotations
  row_anno <- row_anno[1]

  if (row_anno) {

    # Checks to see if row_info is a valid input
    if (class(row_info) != 'data.frame') {
      stop("row_info is meant to be a data.frame")
    }

    # Defining row annotation variable selection
    row_var <- c()

    # Looping through row annotation data frame
    if (is.null(row_anno_var)) {
      for (r in 1:ncol(row_info)) {
        if (is.numeric(row_info[ ,r]) | sum(!duplicated(row_info[ ,r])) < nrow(row_info)) {
          row_var <- c(row_var, colnames(row_info)[r])
        }
      }
    } else {
      k <- match(colnames(row_info), row_anno_var)
      k <- k[!is.na(k)]
      if (length(k) == 0) {
        row_var <- colnames(row_info)
        cat("Selection of row annotation variables does not match column names in original data frame.\n")
      } else {
        row_var <- row_anno_var[k]
        if (length(k) != length(row_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }


    }


    color_vec_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")

    row_color <- matrix(nrow = length(row_var), ncol = nrow(row_info))
    rownames(row_color) <- row_var

    for (v in 1:length(row_var)) {
      if (is.null(row_var_info)) {
        if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5){
          color_vec <- c("white","black")
        } else {
          color_vec <- color_vec_default
        }
      } else {
        if (row_var[v] %in% names(row_var_info)) {
          if ("color" %in% names(row_var_info[[row_var[v]]])){
            color_vec <-  row_var_info[[row_var[v]]]$color
          }
        }
      }

    if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5) {

        varib <- row_info[ ,row_var[v]]
        varib <- varib - min(varib, na.rm=T) + 1
        varib <- varib / min(varib, na.rm=T)

        varib <- round(varib)
        lim <- range(varib,na.rm=T)

        grpUniq <- lim[1]:lim[2]
        rowColUniq <- maPalette(high=color_vec[2], low=color_vec[1], k=length(grpUniq))


        row_color[v, ] <- rowColUniq[varib]

      } else {
        dat <- row_info[ ,row_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          row_color[v, j] <- color_vec[v2]

        }
      }
    }
    RowSideColors <- row_color
  } else {
    RowSideColors <- NULL
  }
  #------------------------------------------
  col_anno <- col_anno[1]

  if (col_anno) {

    # Checks to see if col_info is a valid input
    if (class(col_info) != 'data.frame') {
      stop("col_info is meant to be a data.frame")
    }

    # Defining column annotation variable selection
    col_var <- c()

    # Looping through column annotation data frame
    if (is.null(col_anno_var)) {
      for (r in 1:ncol(col_info)) {
        if (is.numeric(col_info[ ,r]) | sum(!duplicated(col_info[ ,r])) < nrow(col_info)) {
          col_var <- c(col_var, colnames(col_info)[r])
        }
      }
    } else {
      k=match(colnames(col_info),col_anno_var)
      k=k[!is.na(k)]
      if (length(k)==0) {
        col_var=colnames(col_info)
        cat("Selection of column annotation variables does not match column names in original data frame.\n")
      } else {
        col_var=col_anno_var[k]
        if (length(k)!=length(col_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }

    }


    color_vec_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")

    col_color <- matrix(nrow = length(col_var), ncol = nrow(col_info))
    rownames(col_color) <- col_var

    for (v in 1:length(col_var)) {
      if (is.null(col_var_info)) {
        if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {
          color_vec <- c("white","black")
        } else {
          color_vec <- color_vec_default
        }
      } else {
        if (col_var[v] %in% names(col_var_info)) {
          if ("color" %in% names(col_var_info[[col_var[v]]])) {
            color_vec <-  col_var_info[[col_var[v]]]$color
          }
        }
      }

      if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {

        varib <- col_info[ ,col_var[v]]
        varib = varib - min(varib, na.rm=T) + 1
        varib = varib / min(varib, na.rm=T)

        varib = round(varib)
        lim = range(varib,na.rm=T)

        grpUniq=lim[1]:lim[2]
        colColUniq=maPalette(high=color_vec[2],low=color_vec[1],k=length(grpUniq))


        col_color[v, ] <- colColUniq[varib]

      } else {
        dat <- col_info[ ,col_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          col_color[v,j] <- color_vec[v2]

        }
      }
    }
    ColSideColors <- col_color
  } else {
    ColSideColors <- NULL
  }
  #--------------------------------------------------------------------------------------------
  # Global Plot Info
  nc <- ncol(x)
  nr <- nrow(x)

  cexColSide <-  1
  cexRowSide <-  1
  cexCol <- 0.2 + 1 / log10(nc)
  cexRow <- 0.2 + 1 / log10(nr)

  if (!(is.null(plot_info))) {

    if ("cexRowSide" %in% names(plot_info)) {
      cexRowSide <- plot_info$cexRowSide
    }
    if ("cexColSide" %in% names(plot_info)) {
      cexColSide <- plot_info$cexColSide
    }
    if ("cexCol" %in% names(plot_info)) {
      cexCol <- plot_info$cexCol
    }
    if ("cexRow" %in% names(plot_info)){
      cexRow <- plot_info$cexRow
    }
  }

  #--------------------------------------------------------------------------------------------
  ## Labels
  row_lab <- row_lab[1]

  if (row_lab) {
    if(!(is.null(row_lab_vtr))) {
      labRow <- row_lab_vtr
    } else {
      labRow <- rownames(x)
    }
  }
  else {
    labRow <- NA
  }
  #------------------------------------------
  col_lab <- col_lab[1]

  if (col_lab) {
    if(!(is.null(col_lab_vtr))){
      labCol = col_lab_vtr
    } else {
      labCol <- colnames(x)
    }
  }
  else {
    labCol <- NA
  }
  #--------------------------------------------------------------------------------------------
  ## Dendograms
  row_dend <- row_dend[1]

  if (row_dend) {
    if (is.null(row_clust) || class(row_clust %in% c("dendogram", "hclust"))) {
      Rowv <- row_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Rowv <- NA
  }
  #------------------------------------------
  col_dend <- col_dend[1]

  if (col_dend) {
    if (is.null(col_clust) || class(col_clust %in% c("dendogram", "hclust"))) {
      Colv <- col_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Colv <- NA
  }
  #--------------------------------------------------------------------------------------------
  ## Output Files
  if (!is.null(file_name)){

    element <- strsplit(file_name, ".", fixed = TRUE)

    if (element[[1]][2] == "pdf") {
      pdf(file_name, paper = "letter")
    }
    else if (element[[1]][2] == "jpeg") {
      jpeg(filename = file_name)
    }
    else if (element[[1]][2] == "png") {
      png(filename = file_name)
    }
    else if (element[[1]][2] == "tiff") {
      tiff(filename = file_name)
    }
    else {
      stop("File name not in valid format: filename.type")
    }
  }
  #--------------------------------------------------------------------------------------------
  cols <- c("red", "blue", "grey")
  ## Heatmap Output
  heatmap4(x = x, Rowv = Rowv, Colv = Colv, distfun = dist,  symm = FALSE,
           ColSideColors = ColSideColors, RowSideColors = RowSideColors, labCol = labCol, labRow = labRow,
           scale = "none", na.rm = FALSE, margins = c(5, 5), main = h_title, xlab = NULL, ylab = NULL,
           high = cols[1], low = cols[2], mid = cols[3], cexRowSide = cexRowSide, cexColSide = cexColSide, cexRow = cexRow,
           cexCol = cexCol, ...)

  #--------------------------------------------------------------------------------------------
  ## Clears graphics on device
  if (!is.null(file_name)){
    dev.off()
  }
}
```

## 3. Example Data

We will use the preloaded mtcars data set to map and randomly generate column and row annotations.
```{r}
# Main numeric matrix to heatmap
test_x <- as.matrix(mtcars)

# Column annotation df
set.seed(827)

col_rows <- ncol(mtcars)
col_columns <- 3

column_data <- rnorm(col_rows * col_columns)
column_df <- matrix(data = column_data, nrow = col_rows, ncol = col_columns)
colnames(column_df) <- c('C1', 'C2', 'C3')
column_df <- as.data.frame(column_df)

random3 <- sample(1:3, col_rows, replace = TRUE)
column_df$C4 <- random3

# Row annotation df
set.seed(957)

row_rows <- nrow(mtcars)
row_columns <- 4

row_data <- rnorm(row_rows * row_columns)
row_df <- matrix(data = row_data, nrow = row_rows, ncol = row_columns)
colnames(row_df) <- c('R1', 'R2', 'R3', 'R4')
row_df <- as.data.frame(row_df)

```

## 4. Use Cases

> __NOTE__: This is the simplest way to call the heatmap4 function. Defaults are accounted for, see documentation for full list of   defualt options for each arguement.

### 4.1 Annotations and Dendrograms

To display the heatmap with just column annotations and dendrograms:

```{r}

generate_heatmap(test_x, row_anno = FALSE, col_info = column_df,  row_dend = FALSE)

```

The opposite display of just row annotations and dendrograms:

```{r}
# Needs to be fixed to allow for more than one row annotation -- margins error
generate_heatmap(test_x, col_anno = FALSE, row_info = row_df, col_dend = FALSE, row_anno_var = c("R1"))

```


To display heatmap with _both_ column and row annotations and dendrograms:

```{r}

generate_heatmap(test_x, col_info = column_df, row_info = row_df)

```

If the column or row annotation matrixes contain too many columns to display or there is a need to select only a few, the attribute `col_anno_var` (for column annotation limitations) or `row_anno_var` (for row annotation limitations).

The column names for the column annotaion data.frame is: 
```{r, echo=FALSE}
print(colnames(column_df))
```

The column names for the row annotaion data.frame is: 
```{r, echo=FALSE}
print(colnames(row_df))
```

If we only want to display the first column in each data.frame, we would set:

* `col_anno_var = colnames(column_df)[1]`
* `row_anno_var = colnames(row_df)[1]`

_OR_
```{r}

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1"), row_anno_var = c("R1"))

```

To get even more specific, there is the ability to alter annotation specifications, such as color. As an example, we will isolate the `"C2"` column in `column_df` (column annotation data.frame) and change the color scale from `"white", "black"` to `"orange", "blue"`. When specifying the color of a continuous variable, please note that the first color will represent the "lows" and the second color represents the "highs".

```{r}

change <- list(C2 = list(color = c("orange", "blue")))

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2"), row_anno_var = c("R1"), col_var_info = change)

```

The same can be done with row annotations:

```{r}

change <- list(R1 = list(color = c("orange", "blue")))

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2"), row_anno_var = c("R1"), row_var_info = change)

```

If the annotation is not continuous, instead, categorical (like column annotation C4), It will be displayed with distinct colors for each category, the default being: `column_df$C1` versus `column_df$C4`

```{r}

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C4"), row_anno_var = c("R1"))

```

It is also possible to change the color of categorical variables. The order of the colors will match the order of the variables.

```{r}
# Color matches this order
print(unique(column_df$C4))

categorical_color <- list(C4 = list(color = c("blue", "yellow", "green")))

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C4"), row_anno_var = c("R1"), col_var_info = categorical_color)

```

To change the color of both a categorical and continuous variable:
In this example, C4 is categorical and C1, C2, R1 are continuous. Only C1 and C4 have been altered.

```{r}

color_change <- list(C4 = list(color = c("blue", "yellow", "green")), C2 = list(color = c("orange", "blue")))

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2", "C4"), row_anno_var = c("R1"), col_var_info = color_change)

```


### 4.2 Main Plot

The heatmap will do its best to account for the size of the plot and the labels associated with it. However, there is an option for the user to adjust the main plot's column and row labels as well as column and row annotation labels.

* `sideLabCol and sideLabRow` denote heatmap labels  
* `cexColSide and cexRowSide` denote annotation labels


```{r}

main_plot = list("cexCol" = 2, "cexRow" = 2, "cexRowSide" = 3, "cexColSide" = 3)

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C4"), row_anno_var = c("R1"), plot_info = main_plot)

```


To add a title to the heatmap, simply call upon `h_title`

```{r}

generate_heatmap(test_x, col_info = column_df, row_info = row_df, col_anno_var = c("C1"), row_anno_var = c("R1"), h_title = "vignette test")


```



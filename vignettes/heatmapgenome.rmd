---
title: "heatmapegenome.rmd"
author: "Anishka Dhar"
date: "5/3/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{heatmap vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Introduction
This package takes the original heatmap function and reduces the argument complexity. 

A heat map is a false color image (basically image(t(x))) with a dendrogram added to the left side and to the top. Typically, reordering of the rows and columns according to some set of values (row or column means) within the restrictions imposed by the dendrogram is carried out.


```{r, echo=FALSE}
if (F) {
  ## Calling Bioconductor
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

  BiocManager::install("marray")
  load("./data.rda")
}
```

## 2. Loading Libraries

The libraries to call are the following:

```{r}
library(RColorBrewer)
library(marray)
library(heatmap4)
```

```{r}
## 27. Ritu
heatmap4 <- function (x, imp = TRUE, Rowv = NA, Colv = NULL, distfun = dist,
hclustfun = hclust, add.expr, symm = FALSE, revC = identical(Colv, "Rowv"),
scale = "none", na.rm = TRUE, margins = c(5,5), ColSideColors, RowSideColors,
cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), fontRow=1, fontCol=1, labRow = NULL, labCol = NULL, lineRow = NULL, lineCol = NULL, lineColor="black",
totalR=nr, totalC=nc, ncr=NA, ncc=NA, main = NULL, xlab = NULL, ylab = NULL, verbose = getOption("verbose"),
methodR = "ward.D", methodC = "ward.D", zlm = c(-0.5, 0.5), high="green", low="red", mid="black",
addamps=NULL, colamps=NULL, cexAmp=.25, addText=NULL, cexText=1, lwidHeatmap=4, lheiHeatmap=4, lwidRowSide=0.2, lheiColSide=0.2, cexRowSide=1,cexColSide=1, densColor=NULL, sideLabRow=4, sideLabCol=1, layoutRespect=T, sideColSide=c("left","right"), sideRowSide=c("bottom","top"), ...)

{
    
    
    print("heatmap4: zlm")
    print(zlm)
    
    ## 4. Ritu
    if (!is.matrix(x)) {f
        x <- matrix(x,ncol=1)
        if (!is.null(addamps)) {
            addamps <- matrix(addamps,ncol=1)
        }
        ## 19. Ritu
        if (!is.null(addText)) {
            addText <- matrix(addText,ncol=1)
        }
    }
    scale <- if (symm && missing(scale)) "none" else match.arg(scale)
    if (length(di <- dim(x)) != 2 || !is.numeric(x)) stop("`x' must be a numeric matrix")
    nr <- di[1]
    nc <- di[2]
    ## 27. Ritu
    sideRowSide=sideRowSide[1]
    sideColSide=sideColSide[1]
    ## 4. Ritu
    #if (nr <= 1 || nc <= 1) stop("`x' must have at least 2 rows and 2 columns")
    if (nr <= 1 || nc < 1) stop("`x' must have at least 2 rows and 1 column")
    if (!is.numeric(margins) || length(margins) != 2) stop("`margins' must be a numeric vector of length 2")
    doRdend <- !identical(Rowv, NA)
    doCdend <- !identical(Colv, NA)
    if (is.null(Rowv)) Rowv <- rowMeans(x, na.rm = na.rm)
    if (is.null(Colv)) Colv <- colMeans(x, na.rm = na.rm)
    if (doRdend) {
        if (inherits(Rowv, "hclust")) {
            ## 16. Ritu
            hcr <- Rowv
            ddr <- as.dendrogram(hcr)
        } else if (inherits(Rowv, "dendrogram"))
            ddr <- Rowv
        else {
            hcr <- hclustfun(distfun(x), method = methodR)
            ddr <- as.dendrogram(hcr)
            if (!is.logical(Rowv) || Rowv) {
                ddr <- reorder(ddr, Rowv)
                ## 30. Ritu
                hcr <- as.hclust(ddr)
            }
        }
        if (nr != length(rowInd <- order.dendrogram(ddr))) stop("row dendrogram ordering gave index of wrong length")
    } else rowInd <- 1:nr
    if (doCdend) {
        if (inherits(Colv, "hclust")) {
            ## 16. Ritu
            hcc <- Colv
            ddc <- as.dendrogram(hcc)
        } else if (inherits(Colv, "dendrogram"))
            ddc <- Colv
        else if (identical(Colv, "Rowv")) {
            if (nr != nc) stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
            ddc <- ddr
        }
        else {
            hcc <- hclustfun(distfun(if (symm) x else t(x)), method = methodC)
            ddc <- as.dendrogram(hcc)
            if (!is.logical(Colv) || Colv) {
                ddc <- reorder(ddc, Colv)
                ## 30. Ritu
                hcc <- as.hclust(ddc)
            }
        }
        if (nc != length(colInd <- order.dendrogram(ddc))) stop("column dendrogram ordering gave index of wrong\nlength")
    } else colInd <- 1:nc
    ## 28. Ritu
    if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr) else rownames(x)
    if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc) else colnames(x)
    x <- x[rowInd, colInd]
    ## 28. Ritu
    #if (is.null(labRow)) labRow <- if (is.null(rownames(x))) (1:nr)[rowInd] else rownames(x)
    #if (is.null(labCol)) labCol <- if (is.null(colnames(x))) (1:nc)[colInd] else colnames(x)
    if (scale == "row") {
        x <- sweep(x, 1, rowMeans(x, na.rm = na.rm))
        sx <- apply(x, 1, sd, na.rm = na.rm)
        x <- sweep(x, 1, sx, "/")
    } else if (scale == "column") {
        x <- sweep(x, 2, colMeans(x, na.rm = na.rm))
        sx <- apply(x, 2, sd, na.rm = na.rm)
        x <- sweep(x, 2, sx, "/")
    }
    lmat <- rbind(c(NA, 3), 2:1)
    #lwid <- c(if (doRdend) 1 else 0.05, 4)
    #lhei <- c((if (doCdend) 1 else 0.05) + if (!is.null(main)) 0.2 else 0, 4)

    ## 27. Ritu
    ### 7. Ritu
    ##lwid <- c(1, 4)
    ##lhei <- c(1 + if (!is.null(main)) 0.2 else 0, 4)
    #lwid <- c(ifelse(doRdend,1,0.01), 4)
    #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), 4)
    lwid <- c(ifelse(doRdend,1,0.01), lwidHeatmap)
    lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), lheiHeatmap)

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
           # if (!is.character(ColSideColors) || length(ColSideColors) !=
            #    nc)
              #  stop("'ColSideColors' must be a character vector of\nlength ncol(x)")

            ## 6. Ritu
            if (!is.matrix(ColSideColors)) {
                ColSideColors <- matrix(ColSideColors,nrow=1)
                rownames(ColSideColors) <- ""
            }

        ## 11. Ritu
        #lmat <- rbind(lmat[1, ] + 1, c(NA, 1), lmat[2, ] + 1)
        lmat <- rbind(lmat[1, ] + 1, c(rep(NA, ncol(lmat) - 1),1), lmat[2, ] + 1)

        ## 24. Ritu
        lhei <- c(lhei[1], 0.2, lhei[2])
    }
    ## 3. Ritu
    if (!is.null(RowSideColors)) {
        #if (!missing(RowSideColors)) {
            #if (!is.character(RowSideColors) || length(RowSideColors) != nr)
            #    stop("'RowSideColors' must be a character vector of\nlength nrow(x)")
            #lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
            #lwid <- c(lwid[1], 0.2, lwid[2])

        ## 11. Ritu
        if (!is.matrix(RowSideColors)) {
            RowSideColors <- matrix(RowSideColors,nrow=1)
            rownames(RowSideColors) <- ""
        }
        lmat <- cbind(lmat[, 1] + 1, c(rep(NA, nrow(lmat) - 1), 1), lmat[, 2] + 1)
        ## 24. Ritu
        #lwid <- c(lwid[1], 0.2, lwid[2])
        lwid <- c(lwid[1], lwidRowSide, lwid[2])
    }
    lmat[is.na(lmat)] <- 0
    if (verbose) {
        cat("layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

################################
#redo lmat:

    ## 1. Ritu
    #if (!is.matrix(ColSideColors)) {
        #ColSideColors <- matrix(ColSideColors,nrow=1,dimnames=list(names(ColSideColors),1:nc))
    #}

    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        nr.my=nrow(ColSideColors)+2

        ## 11. Ritu
        #nc.my=3
        #nfig=nr.my+2
        #lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        #lmat[nr.my,]=c(nfig-1,1,nfig-2)
        #lmat[1, nc.my]=nfig
        #lmat[2:(nr.my-1),nc.my]=(nfig-3):2
        nc.my=2+ifelse(is.null(RowSideColors),0,nrow(RowSideColors))
        nfig=nr.my+nc.my-1
        lmat=matrix(0, nrow=nr.my, ncol=nc.my)
        if (is.null(RowSideColors)) {
            lmat[nr.my,]=c(nfig-1,nfig-2)
        } else {
            lmat[nr.my,]=c(nfig-1,1:nrow(RowSideColors),nfig-2)
            ## 27. Ritu
            ## 24. Ritu
            ##lwid <- c(ifelse(doRdend,1,0.01), rep(.2, nrow(RowSideColors)), 4)
            #lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), 4)
            lwid <- c(ifelse(doRdend,1,0.01), rep(lwidRowSide, nrow(RowSideColors)), lwidHeatmap)
        }
        lmat[1, nc.my]=nfig
        lmat[2:(nr.my-1),nc.my]=(nfig-3):(nc.my-1)

        ## 11. Ritu
        ### 10. Ritu
        #if (is.null(RowSideColors)) {
        #    lmat=lmat[,c(1,3:ncol(lmat))]
        #    lmat=lmat-1
        #    lmat[lmat==(-1)]=0
        #}

        ## 27. Ritu
        ### 24. Ritu
        #### 7. Ritu
        ###lhei=c(1, rep(.2, nrow(ColSideColors)),4)
        ##lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(ColSideColors)), 4)
        #lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(lheiColSide, nrow(ColSideColors)), 4)
        lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,lheiColSide), rep(lheiColSide, nrow(ColSideColors)), lheiHeatmap)
    }
    
    notRequired=function(x) {
        ## 11. Ritu
        if (!is.null(RowSideColors)) {
            nr.my=nrow(RowSideColors)+2
            nc.my=nrow(ColSideColors)+2
            nfig=nr.my+2
            lmat=matrix(0, nrow=nr.my, ncol=nc.my)
            lmat[nr.my,]=c(nfig-1,1,nfig-2)
            lmat[1, nc.my]=nfig
            lmat[2:(nr.my-1),nc.my]=(nfig-3):2
            if (is.null(ColSideColors)) {
                lmat=lmat[,c(1,3:ncol(lmat))]
                lmat=lmat-1
                lmat[lmat==(-1)]=0
            }
            lhei <- c(ifelse(doCdend,1,0.01) + ifelse(is.null(main),0,0.2), rep(.2, nrow(RowSideColors)), 4)
        }
    }

###################################
    op <- par(no.readonly = TRUE)
    on.exit(par(op))
    if (verbose) {
        cat("Final layout: widths = ", lwid, ", heights = ", lhei, "; lmat=\n")
        print(lmat)
    }

    ## 26. Ritu
    ##layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    #layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = TRUE)
    layoutThis=layout(lmat, widths = lwid, heights = lhei, respect = layoutRespect)
    #layout.show(layoutThis)
    #layout.show(n=nfig)

    ## 3. Ritu
    if (!is.null(RowSideColors)) {
    #if (!missing(RowSideColors)) {
        par(mar = c(margins[1], 0, 0, 0.5))

        ## 11. Ritu
        #if (revC) {
        #    image(rbind(1:nr), col = RowSideColors[rev(rowInd)], axes = FALSE)
        #} else {
        #    image(rbind(1:nr), col = RowSideColors[rowInd], axes = FALSE)
        #}
        if (revC) {
            j=rev(rowInd)
        } else {
            j=rowInd
        }
        for (i in 1:nrow(RowSideColors)) {
            ## 27. Ritu
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            ##image(rbind(1:nr), z=rbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            ##image(cbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            image(rbind(1:nr), col = RowSideColors[i,j], axes = FALSE)
            #image(rbind(1:nr), z=cbind(1:nr),col = RowSideColors[i,j], axes = FALSE, ylim = 0.5 + c(0, totalR))
            
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(RowSideColors[i,j]))) {
                    for (jj in which(is.na(RowSideColors[i,j]))) {
                        rect(-1,jj-0.5,1,jj+0.5,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ### 24. Ritu
            ##mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=1)
            #mtext(side=1, text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
            mtext(side=ifelse(sideRowSide=="bottom",1,3), text=as.character(rownames(RowSideColors)[i]), las=3, cex=cexRowSide)
        }
    }
    ## 2. Ritu
    if (!is.null(ColSideColors)) {
        #if (!missing(ColSideColors)) {
        par(mar = c(0.5, 0, 0, margins[2]))
        for (i in 1:nrow(ColSideColors)) {
            ## 9. Ritu
            #image(cbind(1:nc), col = ColSideColors[i,colInd], axes = FALSE)
            image(cbind(1:nc), z=cbind(1:nc),col = ColSideColors[i,colInd], axes = FALSE, xlim = 0.5 + c(0, totalC))
            ## 24. Ritu
            if (!is.null(densColor)) {
                if (any(is.na(ColSideColors[i,colInd]))) {
                    for (jj in which(is.na(ColSideColors[i,colInd]))) {
                        rect(jj-0.5,-1,jj+0.5,1,density=densColor)
                    }
                }
            }
            ## 26. Ritu
            ## 24. Ritu
            #mtext(side=2, text=as.character(rownames(ColSideColors)[i]), las=1, cex=1)
            mtext(side=ifelse(sideColSide=="left",2,4), text=as.character(rownames(ColSideColors)[i]), las=1, cex=cexColSide)
        }
    }
    par(mar = c(margins[1], 0, 0, margins[2]))
    if (!symm || scale != "none")
        x <- t(x)
    if (revC) {
        iy <- nr:1
        ddr <- rev(ddr)
        x <- x[, iy]
    }
    else iy <- 1:nr
    x.floor <- x
    for (i in 1:ncol(x)) {
        ind1 <- (1:length(x[, i]))[x[, i] >= zlm[2] & !is.na(x[,i])]
        ind2 <- (1:length(x[, i]))[x[, i] <= zlm[1] & !is.na(x[,i])]
        x.floor[, i][ind1] <- rep((zlm[2] - 0.01), length(ind1))
        x.floor[, i][ind2] <- rep((zlm[1] + 0.01), length(ind2))
    }
    ## 5. Ritu
    #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, nc), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
    if (length(high)>1) {
        ## 20. Ritu
        colThis=high
    } else {
        colThis=maPalette(high = high, low = low, mid = mid)
    }
    if (nc==1) {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:(2*nc), 1:nr, rbind(x.floor,x.floor), xlim = 0.5 + c(0, 2*totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    } else {
        ## 27. Ritu
        ### 20. Ritu
        ##image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = maPalette(high = high, low = low, mid = mid), zlim = zlm, ...)
        #image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, nr), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
        image(1:nc, 1:nr, x.floor, xlim = 0.5 + c(0, totalC), ylim = 0.5 + c(0, totalR), axes = FALSE, xlab = "", ylab = "", col = colThis, zlim = zlm, ...)
    }
    ## 15. Ritu
    if (!is.null(lineCol)) {
        ## 22. Ritu
        #abline(v=lineCol)
        abline(v=lineCol,col=lineColor)
    }
    ## 15. Ritu
    if (!is.null(lineRow)) {
        ## 27. Ritu
        ### 22. Ritu
        ##abline(h=lineRow)
        #abline(h=lineRow,col=lineColor)
        for (i in lineRow) lines(x=c(1-0.5,nc+0.5),y=rep(i,2), col=lineColor)
    }

##################

## 19. Ritu
if (!is.null(addText)) {
    addText=addText[rowInd, colInd]
    if (!is.matrix(addText)) {
        addText <- matrix(addText,ncol=1)
    }
    for (i in 1:ncol(addText)) {
        j=which(!is.na(addText[,i]))
        ## 23. Ritu
        #points(rep(i, length(j)), j, pch=addText[j,i])
        if (length(j)!=0) text(i, j, labels=addText[j,i], cex=cexText)
    }
}

if (!is.null(addamps)) {
    addamps=addamps[rowInd, colInd]
    ## 4. Ritu
    if (!is.matrix(addamps)) {
        addamps <- matrix(addamps,ncol=1)
    }
    for (i in 1:ncol(addamps)) {
        amp=which(addamps[,i]>0)
        ## 12. Ritu
        ### 8. Ritu
        ##points(rep(i, length(amp)), amp, col=colamps, cex=.75, pch=20)
        #points(rep(i, length(amp)), amp, col=colamps, cex=.25, pch=20)
        points(rep(i, length(amp)), amp, col=colamps, cex=cexAmp, pch=20)
    }
 }
    
################

    ## 25. Ritu
    ### 17. Ritu
    ##axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
    #axis(1, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    axis(sideLabCol, 1:nc, labels = labCol[colInd], las = 2, line = -0.5, tick = 0, cex.axis = cexCol, font.axis=fontCol)
    if (!is.null(xlab))
        mtext(xlab, side = 1, line = margins[1] - 1.25)
    ## 25. Ritu
    ### 17. Ritu
    ##axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
    #axis(4, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    axis(sideLabRow, iy, labels = labRow[rowInd], las = 2, line = -0.5, tick = 0, cex.axis = cexRow, font.axis=fontRow)
    if (!is.null(ylab))
        mtext(ylab, side = 4, line = margins[2] - 1.25)
    if (!missing(add.expr))
        eval(substitute(add.expr))
    ## 27. Ritu
    #par(mar = c(margins[1], 0, 0, 0))
    xr=ifelse(totalR==nr,margins[1],2*(totalR-nr)+1+margins[1])
    xc=0
    par(mar = c(xr, 0, 0, xc))
    if (doRdend) {
        plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcr") & !is.na(ncr)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcr,k=ncr) else stop("Must be of class hclust to delineate clusters")
            if (class(hcr)=="hclust") rect.hclust.my(hcr,k=ncr,horiz=TRUE) else stop("Must be of class hclust to delineate clusters")
        }
    } else {
        frame()
    }
    ## 27. Ritu
    ## 9. Ritu
    #if (totalC==nc) {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, margins[2]))
    #} else {
    #    par(mar = c(0, 0, if (!is.null(main)) 1 else 0, 2*(totalC-nc)+1+margins[2]))
    #}
    xr=0
    xc=ifelse(totalC==nc,margins[2],2*(totalC-nc)+1+margins[2])
    par(mar = c(xr, 0, if (!is.null(main)) 1 else 0, xc))
    if (doCdend) {
        plot(ddc, axes = FALSE, xaxs = "i", leaflab = "none")
        ## 16. Ritu
        if (exists("hcc") & !is.na(ncc)) {
            ## 18. Ritu
            #if (class(hcc)=="hclust") rect.hclust(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
            if (class(hcc)=="hclust") rect.hclust.my(hcc,k=ncc) else stop("Must be of class hclust to delineate clusters")
        }
    } else if (!is.null(main)) {
        frame()
    }
    if (!is.null(main)) {
        ## 27. Ritu
        if (doCdend) {
            title(main, cex.main=0.8 * op[["cex.main"]])
            #text(x=20,y=5,main,cex=1 * op[["cex.main"]],font=2)
        } else {
            text(x=0.5,y=0.5,main,cex=1.5 * op[["cex.main"]],font=2)
        }
        #title(main, cex.main = 1.5 * op[["cex.main"]])
        #title(main, cex.main = 1.5 * op[["cex.main"]],line = margins[1] - 1.25)
        #plot(1,type="n",xaxt="n",yaxt="n",xlab="",ylab="");
        #text(x=10+margins[1] - 1.25,y=1,"test",cex=1.5 * op[["cex.main"]],)
        #text(x=1,y=1,c("test","ok"),cex=1.5 * op[["cex.main"]])
        #text(x=0.5,y=1,c("tex"),cex=1.5 * op[["cex.main"]])
        #points(rep(0,10),1:10)
    }

    ## 13. Ritu
    #invisible(list(rowInd = rowInd, colInd = colInd))
    out=list(rowInd = rowInd, colInd = colInd, rowClust=NULL, colClust=NULL)

    ## 14. Ritu
    #if (doRdend) out$rowClust=hcr
    #if (doCdend) out$colClust=hcc
    if (exists("hcr")) out$rowClust=hcr
    if (exists("hcc")) out$colClust=hcc
    
    ## 29. Ritu
    if (exists("hcr") & !is.na(ncr)) {
        y=cutree(hcr,ncr)
        y=y[out$rowInd]
        out$rowClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncr) {
            out$rowClustId[which(y==y[k1[k]])]=k
        }
    }
    if (exists("hcc") & !is.na(ncc)) {
        y=cutree(hcc,ncc)
        y=y[out$colInd]
        out$colClustId=rep(NA,length(y))
        k1=which(!duplicated(y))
        for (k in 1:ncc) {
            out$colClustId[which(y==y[k1[k]])]=k
        }
    }

    invisible(out)
}

rect.hclust.my=function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL, horiz = FALSE) {
    if (length(h) > 1L | length(k) > 1L) stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k))
        stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    } else if (is.null(k)) {
        stop("specify exactly one of 'k' and 'h'")
    }
    if (k < 2 | k > length(tree$height))
    stop(gettextf("k must be between 2 and %d", length(tree$height)), domain = NA)
    if (is.null(cluster))
    cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which))
        stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in seq_along(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which))
    which <- 1L:k
    if (any(which > k))
    stop(gettextf("all elements of 'which' must be between 1 and %d", k), domain = NA)
    border <- rep_len(border, length(which))
    retval <- list()
    for (n in seq_along(which)) {
        if (horiz) {
            ## 18. Ritu
            rect(mean(rev(tree$height)[(k - 1):k]), m[which[n]] + 0.66, par("usr")[2L], m[which[n] + 1] + 0.33, border = border[n])
        } else {
            rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n])
        }
#        rect(xleft, ybottom, xright, ytop, density = NULL, angle = 45,col = NA, border = NULL, lty = par("lty"), lwd = par("lwd"),
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}

######################################################################
######################################################################
######################################################################


script <- function() {
library(RColorBrewer)
library(marray)
library(sma)
library(aCGH)

#row colors (chromosomes)

chrominfo=human.chrom.info.Jul03
clinfo <- clones.info(tumor.acgh)
chromcols <- rep(NA, nrow(clinfo))

for (i in 1:23)
{
    if (is.odd(i))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "yellowgreen"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "green"
        chromcols[which(clinfo$Chrom==i)] <- "gray10"
        
    }
    else if (!(is.odd(i)))
    {
        #chromcols[which(clinfo$Chrom==i & clinfo$kb >= chrominfo$centromere[i])] <- "skyblue"
        #chromcols[which(clinfo$Chrom==i & clinfo$kb < chrominfo$centromere[i])] <- "blue"
        chromcols[which(clinfo$Chrom==i)] <- "gray90"
        
    }
}

sampnm1 <- sample.names(tumor.acgh)[ind.match.tumor]

ind.samp <- which(!is.na(ind.match.tumor))
ind.cl=which(clinfo$Chrom<=23 & clinfo$Clone!="RMC01P009")

#create color bars accoridng to clinical variables

sampCols=matrix(NA, nrow=7, ncol=nrow(phenData))

#expression subtype

rsp=as.numeric(phenData$subCor)
tmp=brewer.pal(length(unique(rsp[!is.na(rsp)])),"Accent")

sampcols <- rep(NA, length(rsp))
for (i in 1:length(tmp))
{
    sampcols[which(rsp==i)]=tmp[i]
}
sampcols[which(sampcols=="#FFFF99")]="yellow2"
sampCols[1,]=sampcols

#pr
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$pr=="pos")]=1
rsp[which(phenData$pr=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[2,]=sampcols

#er
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$er=="pos")]=1
rsp[which(phenData$er=="neg")]=0
sampcols[which(rsp==1)]="blue"
sampcols[which(rsp==0)]="skyblue"

sampCols[3,]=sampcols

#p53
rsp=rep(NA, nrow(phenData))
rsp[which(phenData$p53==0)]=1
rsp[which(phenData$p53==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[4,]=sampcols

#ki67

rsp=I(phenData$ki67>10)
rsp[which(rsp==TRUE)]=2
rsp[which(rsp==FALSE)]=1

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[5,]=sampcols

#size

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$size<=median(phenData$size, na.rm=T))]=1
rsp[which(phenData$size>median(phenData$size, na.rm=T))]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[6,]=sampcols

#nodal.status

rsp=rep(NA, nrow(phenData))
rsp[which(phenData$nodal.status==0)]=1
rsp[which(phenData$nodal.status==1)]=2

sampcols <- rep(NA, length(rsp))
sampcols[which(rsp==1)]="skyblue"
sampcols[which(rsp==2)]="blue"

sampCols[7,]=sampcols

########################

rownames(sampCols)=c("Expression subtype", "PR status", "ER status", "p53 status", "ki67 status", "size", "nodal status")

#########################

#main data (smoothed with outliers)
tmp <- tumor.smoothed.impute.aber$aber.val[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

#amplifications to be added as yellow dots
tmpamp <- tumor.amplif[ind.cl,][rev(1:nrow(clinfo[ind.cl,])),ind.match.tumor]

postscript("try.ps", paper="letter")
try10=heatmap3(x=tmp[,ind.samp], Rowv=NA, Colv=NULL, distfun = dist.cor.func, hclustfun = hclust,  symm=F, ColSideColors = sampCols[,ind.samp], RowSideColors=chromcols[ind.cl][rev(1:length(chromcols[ind.cl]))], labCol=as.character(sampnm1)[ind.samp], labRow=NA, scale="none", na.rm = F, margins = c(5, 5), main = NULL, xlab = NULL, ylab = NULL, zlm=c(-.5,.5), addamps=tmpamp[,ind.samp], colamps="yellow")
dev.off()
}

```

``` {r}
## 7. Ritu 04/13/22 - Fix continuous row color bar
## 8. Ritu 05/13/22 - row_var not col_var for row color bar
## 9. Ritu 06/09/22 - Set no. of axis labels to 5 (k=5) in heatmapColorBar

## Wrapped heatmap function
generate_heatmap <- function(x, col_lab = c(TRUE, FALSE), row_lab = c(TRUE, FALSE), col_lab_vtr = NULL,
                             row_lab_vtr = NULL, col_anno = c(TRUE, FALSE), row_anno = c(TRUE, FALSE), col_info = NULL,
                             row_info = NULL, col_anno_var = NULL, row_anno_var = NULL, col_var_info = NULL,
                             row_var_info = NULL, col_dend = c(TRUE, FALSE), row_dend = c(TRUE, FALSE),
                             col_anno_name=NULL, row_anno_name=NULL,
                             # review col/row_clust and _dend
                             col_clust = NULL, row_clust = NULL,
                             plot_info = list(margins=c(5,5),cexCol=NULL,cexRow=NULL,cexColSide=NULL,cexRowSide=NULL,colorCatCol=NULL,colorCatRow=NULL,colorContCol=NULL,colorContRow=NULL),
                             file_name = NULL, h_title = NULL,input_legend = c(TRUE, FALSE), legend_title = NULL, heatmap_color=c("red", "blue", "grey"), zlm=c(-0.5, 0.5), ...)
{

  #--------------------------------------------------------------------------------------------
  ## Annotations
  input_legend <- input_legend[1]
  row_anno <- row_anno[1]
  col_anno <- col_anno[1]

  if (row_anno) {

    # Checks to see if row_info is a valid input
    if (class(row_info) != 'data.frame') {
      stop("row_info is meant to be a data.frame")
    }

    # Defining row annotation variable selection
    row_var <- c()

    # Looping through row annotation data frame
    if (is.null(row_anno_var)) {
      for (r in 1:ncol(row_info)) {
        if (is.numeric(row_info[ ,r]) | sum(!duplicated(row_info[ ,r])) < nrow(row_info)) {
          row_var <- c(row_var, colnames(row_info)[r])
        }
      }
    } else {
      k <- match(colnames(row_info), row_anno_var)
      k <- k[!is.na(k)]
      if (length(k) == 0) {
        row_var <- colnames(row_info)
        cat("Selection of row annotation variables does not match column names in original data frame.\n")
      } else {
        row_var <- row_anno_var[k]
        if (length(k) != length(row_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }


    }

    color_vec_cat_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")
    color_vec_cont_default <- c("white","black")
    if ("colorCatRow"%in%names(plot_info) && !is.null(plot_info$colorCatRow)) color_vec_cat_default <- plot_info$colorCatRow
    if ("colorContRow"%in%names(plot_info) && !is.null(plot_info$colorContRow)) color_vec_cont_default <- plot_info$colorContRow

    row_color <- matrix(nrow = length(row_var), ncol = nrow(row_info))
    if (is.null(row_anno_name)) {
        #rownames(row_color) <- paste(rownames(row_var)," ",sep="")
        rownames(row_color) <- paste(row_var," ",sep="")
    } else {
     k <- match(colnames(row_info), row_anno_var)
     k <- k[!is.na(k)]
     rownames(row_color) <- row_anno_name[k]
    }
    
    for (v in 1:length(row_var)) {
      if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5){
        color_vec <- color_vec_cont_default
      } else {
          color_vec <- color_vec_cat_default
      }
      if (!is.null(row_var_info)) {
        if (row_var[v] %in% names(row_var_info)) {
          if ("color" %in% names(row_var_info[[row_var[v]]])){
            color_vec <-  row_var_info[[row_var[v]]]$color
          }
        }
      }

    if (is.numeric(row_info[ ,row_var[v]]) & length(unique(row_info[ ,row_var[v]])) > 5) {

        varib <- row_info[ ,row_var[v]]
        if ("limit" %in% names(row_var_info[[row_var[v]]])){
            lim <-  row_var_info[[row_var[v]]]$limit
            varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
            ## 7. Ritu
            lim=lim+lim[2]+1
        } else {
            if (F) {
                varib = varib - min(varib, na.rm=T) + 1
                varib = varib / min(varib, na.rm=T)
            }
            if (T) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=(100*(varib-min(varib,na.rm=T))/x1)+1
            }

            varib <- round(varib)
            lim <- range(varib,na.rm=T)
        }

        grpUniq <- lim[1]:lim[2]
        rowColUniq <- maPalette(high=color_vec[2], low=color_vec[1], k=length(grpUniq))

        ## 7. Ritu
        #row_color[v, ] <- rowColUniq[varib]
        j=match(varib,grpUniq); j1=which(!is.na(j)); j2=j[j1]
        row_color[v,j1] <- rowColUniq[j2]

      } else {
        dat <- row_info[ ,row_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          ## 8. Ritu
          #cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
          cat("Not enough colors for ,",row_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          row_color[v, j] <- color_vec[v2]

        }
      }
    }
    RowSideColors <- row_color
      if (!is.null(row_anno_name)) {
          k=match(row_anno_name,rownames(RowSideColors))
          k=k[!is.na(k)]
          nm=rownames(RowSideColors)
          RowSideColors=RowSideColors[k,]
          if (!is.matrix(RowSideColors)) {
              RowSideColors=matrix(RowSideColors,nrow=1)
              rownames(RowSideColors)=nm
          }
      }
  } else {
    RowSideColors <- NULL
  }
  #------------------------------------------

  if (col_anno) {

    # Checks to see if col_info is a valid input
    if (class(col_info) != 'data.frame') {
      stop("col_info is meant to be a data.frame")
    }

    # Defining column annotation variable selection
    col_var <- c()

    # Looping through column annotation data frame
    if (is.null(col_anno_var)) {
      for (r in 1:ncol(col_info)) {
        if (is.numeric(col_info[ ,r]) | sum(!duplicated(col_info[ ,r])) < nrow(col_info)) {
          col_var <- c(col_var, colnames(col_info)[r])
        }
      }
    } else {
        #k=match(colnames(col_info),col_anno_var)
        #k=k[!is.na(k)]
      k=which(col_anno_var%in%colnames(col_info))
      if (length(k)==0) {
        col_var=colnames(col_info)
        cat("Selection of column annotation variables does not match column names in original data frame.\n")
      } else {
        col_var=col_anno_var[k]
        if (length(k)!=length(col_anno_var)) cat("Selection of column annotation variables does not match column names in original data frame.\n")
      }

    }

    color_vec_cat_default <- c("skyblue", "blue", "yellow", "purple", "black", "red", "orange", "green", "cyan", "darkgreen")
    color_vec_cont_default <- c("white","black")
    if ("colorCatCol"%in%names(plot_info) && !is.null(plot_info$colorCatCol)) color_vec_cat_default <- plot_info$colorCatCol
    if ("colorContCol"%in%names(plot_info) && !is.null(plot_info$colorContCol)) color_vec_cont_default <- plot_info$colorContCol

    col_color <- matrix(nrow = length(col_var), ncol = nrow(col_info))
    if (is.null(col_anno_name)) {
        #rownames(col_color) <- paste(rownames(col_color)," ",sep="")
        rownames(col_color) <- paste(col_var," ",sep="")
    } else {
        #k=match(colnames(col_info),col_anno_var)
        #if (any(is.na(k))) cat("Mismatched column variables!!!")
        #k=k[!is.na(k)]
        if (length(col_anno_var)!=length(col_anno_name)) cat("Mismatched column variables!!!")
        k=which(col_anno_var%in%colnames(col_info))
        rownames(col_color) <- col_anno_name[k]
    }
    
    for (v in 1:length(col_var)) {
      if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {
        color_vec <- color_vec_cont_default
      } else {
          color_vec <- color_vec_cat_default
      }
      if (!is.null(col_var_info)) {
        if (col_var[v] %in% names(col_var_info)) {
          if ("color" %in% names(col_var_info[[col_var[v]]])) {
            color_vec <-  col_var_info[[col_var[v]]]$color
          }
        }
      }

      if (is.numeric(col_info[ ,col_var[v]]) & length(unique(col_info[ ,col_var[v]])) > 5) {

        varib <- col_info[ ,col_var[v]]
        if ("limit" %in% names(col_var_info[[col_var[v]]])){
            if (F) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=((varib-min(varib,na.rm=T))/x1)+1
                lim <-  col_var_info[[col_var[v]]]$limit+1
            } else {
                lim <-  col_var_info[[col_var[v]]]$limit
                varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
                lim=lim+lim[2]+1
            }
        } else {
            if (F) {
                varib = varib - min(varib, na.rm=T) + 1
                varib = varib / min(varib, na.rm=T)
            }
            if (T) {
                x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                varib=(100*(varib-min(varib,na.rm=T))/x1)+1
            }
            varib <- round(varib)
            lim <- range(varib,na.rm=T)
        }

        grpUniq=lim[1]:lim[2]
        colColUniq=maPalette(high=color_vec[2],low=color_vec[1],k=length(grpUniq))

        j=match(varib,grpUniq);j1=which(!is.na(j)); j2=j[j1]
        col_color[v,j1] <- colColUniq[j2]
      } else {
        dat <- col_info[ ,col_var[v]]
        datUniq <- sort(unique(dat))
        if (length(datUniq) > length(color_vec)) {
          color_vec <- rainbow(length(datUniq))
          cat("Not enough colors for ,",col_var[v],"; They have been assigned random colors in the meantime.\n")
        }
        for (v2 in 1:length(datUniq)) {
          j <-  which(dat == datUniq[v2])
          col_color[v,j] <- color_vec[v2]
        }
      }
    }
    ColSideColors <- col_color
    if (!is.null(col_anno_name)) {
        k=match(col_anno_name,rownames(ColSideColors))
        k=k[!is.na(k)]
        nm=rownames(ColSideColors)
        ColSideColors=ColSideColors[k,]
        if (!is.matrix(ColSideColors)) {
            ColSideColors=matrix(ColSideColors,nrow=1)
            rownames(ColSideColors)=nm
        }
    }
  } else {
    ColSideColors <- NULL
  }
  #--------------------------------------------------------------------------------------------
  # Global Plot Info
  nc <- ncol(x)
  nr <- nrow(x)

  margins=c(5,5)
  cexColSide <-  1
  cexRowSide <-  1
  cexCol <- 0.2 + 1 / log10(nc)
  cexRow <- 0.2 + 1 / log10(nr)

  if (!(is.null(plot_info))) {
    if ("margins" %in% names(plot_info)){
      margins <- plot_info$margins
    }
    if ("cexRowSide" %in% names(plot_info)) {
      cexRowSide <- plot_info$cexRowSide
    }
    if ("cexColSide" %in% names(plot_info)) {
      cexColSide <- plot_info$cexColSide
    }
    if ("cexCol" %in% names(plot_info)) {
      cexCol <- plot_info$cexCol
    }
    if ("cexRow" %in% names(plot_info)){
      cexRow <- plot_info$cexRow
    }
  }

  #--------------------------------------------------------------------------------------------
  ## Labels
  row_lab <- row_lab[1]

  if (row_lab) {
    if(!(is.null(row_lab_vtr))) {
      labRow <- row_lab_vtr
    } else {
      labRow <- rownames(x)
    }
  }
  else {
    labRow <- NA
  }
  #------------------------------------------
  col_lab <- col_lab[1]

  if (col_lab) {
    if(!(is.null(col_lab_vtr))){
      labCol = col_lab_vtr
    } else {
      labCol <- colnames(x)
    }
  }
  else {
    labCol <- NA
  }
  
  #--------------------------------------------------------------------------------------------
  ## Dendograms
  row_dend <- row_dend[1]

  if (row_dend) {
    if (is.null(row_clust) || class(row_clust) %in% c("dendogram", "hclust")) {
      Rowv <- row_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Rowv <- NA
  }
  #------------------------------------------
  col_dend <- col_dend[1]

  if (col_dend) {
    if (is.null(col_clust) || class(col_clust)%in%c("dendogram", "hclust")) {
      Colv <- col_clust
    }
    else {
      stop("Error in column clustering class.")
    }
  }
  else {
    Colv <- NA
  }
  #--------------------------------------------------------------------------------------------
  ## Legend
  heatmapColorBar <- function(zlm=c(-.5,.5),cols=c("green","red","black"),main=NULL) 
    
    {
      if (length(cols)==3) {
          try <- maPalette(high=cols[1], low=cols[2], mid=cols[3])
      } else {
          ## 5. Ritu
          try <- maPalette(high=cols[1], low=cols[2])
      }
      maColorBar(try, scale=zlm,main=main)
  }
  
  sampleColorLegend.my <- function(tls,col=NULL,lty=NULL,legendTitle=NULL,cex=NULL,density=NULL) {
    nTypes <- length(tls)
    if (is.null(col)) {
      cl <- brewer.pal(8, "Accent")
      cl <- cl[1:min(nTypes,length(cl))]
      if (length(cl)<nTypes) {
        cl=c(brewer.pal(nTypes,"Set3"),brewer.pal(nTypes,"Set2"))[1:nTypes]
        cl[1] <- "#1F78B4"
        if (length(cl)>8) {
          cl[9] <- "#999999"
        }
      }
      cl <- cl[1:nTypes]
      cl[cl=="#FFFF99"]="#FFFF60"
    } else {
      cl <- col
    }
    fill=col=NULL
    if (is.null(lty)) {
      fill=cl
    } else {
      col=cl
    }
    n <- length(tls)
    if (n!=0) {
        ii <- 1:length(tls)
        if (is.null(cex)) {
          cex=ifelse(max(nchar(tls))>13,1.5,3)
          if (nTypes>6) {cex=1.5}
        }
        plot(0:length(tls),0:length(tls),type="n",axes=F,xlab="",ylab="")
        if (is.null(lty)) {
          if (is.null(density)) {
            legend(0,length(tls),tls,fill=fill,col=col,lty=lty,cex=cex,title=legendTitle)
          } else {
            ## 6. Ritu
            legend(0,length(tls),tls,col=fill,lty=lty,cex=cex,density=density,title=legendTitle)
            if (F) {
              text(1,k-1,legendTitle)
              for (k in 1:length(tls)) {
                rect(0,k-0.5,1,k+0.5,col=fill[k],density=density)
                text(2,k,tls[k])
              }
            }
          }
        } else {
          legend(0,length(tls),tls,col=col,lty=lty,cex=cex,title=legendTitle)
        }
    }
  }
  #--------------------------------------------------------------------------------------------
  ## Output Files
  if (!is.null(file_name)){

    element <- strsplit(file_name, ".", fixed = TRUE)

    if (element[[1]][2] == "pdf") {
      pdf(file_name, paper = "letter")
    }
    else if (element[[1]][2] == "jpeg") {
      jpeg(filename = file_name)
    }
    else if (element[[1]][2] == "png") {
      png(filename = file_name)
    }
    else if (element[[1]][2] == "tiff") {
      tiff(filename = file_name)
    }
    else {
      stop("File name not in valid format: filename.type")
    }
  }
  #--------------------------------------------------------------------------------------------
  cols <- heatmap_color
  
  ## Heatmap Output
  clusterObj=heatmap4(x = x, Rowv = Rowv, Colv = Colv, symm = FALSE,
           ColSideColors = ColSideColors, RowSideColors = RowSideColors, labCol = labCol, labRow = labRow,
           scale = "none", na.rm = FALSE, margins = margins, main = h_title, xlab = NULL, ylab = NULL,
           high = cols[1], low = cols[2], mid = cols[3], cexRowSide = cexRowSide, cexColSide = cexColSide, cexRow = cexRow,
           cexCol = cexCol, zlm=zlm, ...)
  ## Legend Output
  if (input_legend) {
      #cat("Legends not yet implemented ....")
      if (T) {
          cat("zlm:",exists("zlm"),"\n")
          if (!exists("zlm")) zlm=c(-.5,.5)
          ## 9. Ritu
          #heatmapColorBar(cols=cols,limit=zlm)
          heatmapColorBar(cols=cols,limit=zlm,k=5)
          if (input_legend & row_anno) {
              for (vId in 1:length(row_var))
            sampleColorLegend(tls = row_var, col = row_color, lty = NULL, legendTitle = legend_title, cex = NULL)
          }
          if (input_legend & row_anno) {
            cat("Legends ....")
            for (vId in 1:length(row_var)) {
                nm=sub("^ +","",sub(" +$","",rownames(row_color)[vId]))
                x=sort(unique(row_info[,row_var[vId]]))
                color_vec <- color_vec_cat_default
                if (!is.null(row_var_info)) {
                  if (row_var[vId] %in% names(row_var_info)) {
                    if ("color" %in% names(row_var_info[[row_var[vId]]])) {
                      color_vec <-  row_var_info[[row_var[vId]]]$color
                    }
                  if ("level" %in% names(row_var_info[[row_var[vId]]])) {
                    x <-  row_var_info[[row_var[vId]]]$level
                  }
                  }
                }
                sampleColorLegend(tls=x,col=color_vec,lty=NULL,legendTitle=nm,cex=NULL)
            }
          }
          if (input_legend & col_anno) {
            cat("Legends ....")
            for (vId in 1:length(col_var)) {
                nm=sub("^ +","",sub(" +$","",rownames(col_color)[vId]))
                if (is.numeric(col_info[ ,col_var[vId]]) & length(unique(col_info[ ,col_var[vId]])) > 5) {
                    varib <- col_info[ ,col_var[vId]]
                    color_vec <- color_vec_cont_default
                    if ("limit" %in% names(col_var_info[[col_var[vId]]])){
                        lim <-  col_var_info[[col_var[vId]]]$limit
                        varib=round(varib); varib[varib<lim[1]]=lim[1]; varib[varib>lim[2]]=lim[2]; varib=varib+lim[2]+1
                    } else {
                        x1=max(abs(varib-min(varib,na.rm=T)),na.rm=T)
                        varib=(100*(varib-min(varib,na.rm=T))/x1)+1
                        varib <- round(varib)
                        lim <- range(varib,na.rm=T)
                        lim <- round(range(col_info[ ,col_var[vId]],na.rm=T),2)
                    }
                    color_vec=rev(color_vec)
                    heatmapColorBar(cols=color_vec,limit=lim)

                } else {
                    x=sort(unique(col_info[,col_var[vId]]))
                    color_vec <- color_vec_cat_default
                    if (!is.null(col_var_info)) {
                      if (col_var[vId] %in% names(col_var_info)) {
                        if ("color" %in% names(col_var_info[[col_var[vId]]])) {
                          color_vec <-  col_var_info[[col_var[vId]]]$color
                        }
                      if ("level" %in% names(col_var_info[[col_var[vId]]])) {
                        x <-  col_var_info[[col_var[vId]]]$level
                      }
                      }
                    }
                    sampleColorLegend(tls=x,col=color_vec,lty=NULL,legendTitle=nm,cex=NULL)
                }
            }
          }
          # sampleColorLegend(tls = c("N0", "N+"), col = samColUniq[1:2], lty = NULL, legendTitle = "Node", cex = NULL)
          # tls = title, each annotation variable, default: used annotation variables, for loop
          # col = color, default: annotation default or specified by user
          # lty = line type, deafault = NULL
          # legendTitle, default = NULL
          # cex = text size, default = NULL
      }
  }

  #--------------------------------------------------------------------------------------------
  ## Clears graphics on device
  if (!is.null(file_name)){
    dev.off()
  }
  
  invisible(clusterObj)

}

```


## 3. Example Data

We will use the preloaded data set to map and randomly generate column and row annotations.
```{r}
# Main numeric matrix to heatmap
test <- as.matrix(genomeData)

# Column annotation df
set.seed(100)

col_rows <- ncol(genomeData)
col_columns <- 3

column_data <- rnorm(col_rows * col_columns)
column_df <- matrix(data = column_data, nrow = col_rows, ncol = col_columns)
colnames(column_df) <- c('C1', 'C2', 'C3')
column_df <- as.data.frame(column_df)
col_info <- column_df

random3 <- sample(1:2, col_rows, replace = TRUE)
column_df$C4 <- random3

# Row annotation df
set.seed(50)

row_rows <- nrow(genomeData)
row_columns <- 2

row_data <- rnorm(row_rows * row_columns)
row_df <- matrix(data = row_data, nrow = row_rows, ncol = row_columns)
rownames(row_df) <- c('V1', 'V3') 
row_df <- as.data.frame(row_df)
row_info <- row_df



```

```{r}
#basic heatmap set up; row dend, col dend, row anno, col anno  
generate_heatmap(test, row_info = row_df, col_info = column_df)
```

```{r}
#empty, heatmap only 
generate_heatmap(test, col_lab = FALSE, row_lab = FALSE, col_lab_vtr = NULL, row_lab_vtr = NULL, col_anno = FALSE, row_anno = FALSE, col_info = column_df, row_info = row_df, col_anno_var = NULL, row_anno_var = NULL, col_var_info = NULL, row_var_info = NULL, col_dend = FALSE, row_dend = FALSE, col_clust = FALSE, row_clust = FALSE)
```

```{r}
#col dend and row_dend only  
generate_heatmap(test, col_lab = TRUE, row_lab = FALSE, col_lab_vtr = NULL, row_lab_vtr = NULL, col_anno = FALSE, row_anno = FALSE, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2"), row_anno_var = ("V1"))
```

```{r}
#col anno, col dend, row dend 
generate_heatmap(test, col_lab = TRUE, row_lab = TRUE, col_lab_vtr = NULL, row_lab_vtr = NULL, col_anno = TRUE, row_anno = FALSE, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2"), row_anno_var = c("V1"))
```

```{r}
#col anno, col dend, row anno, row dend 
generate_heatmap(test, col_lab = TRUE, row_lab = TRUE, col_lab_vtr = NULL, row_lab_vtr = NULL, col_anno = TRUE, row_anno = TRUE, col_info = column_df, row_info = row_df, col_anno_var = c("C1", "C2"), row_anno_var = c("V1"))
```
